<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[纳兰若水]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2019-06-26T11:25:48.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[纳兰若水]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【译】A taste of MVVM and Reactive paradigm]]></title>
    <link href="http://yoursite.com/2019/06/26/mvvm%E3%80%90%E8%AF%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/26/mvvm【译】/</id>
    <published>2019-06-26T15:48:03.000Z</published>
    <updated>2019-06-26T11:25:48.000Z</updated>
    <content type="html"><![CDATA[<p>【译】A taste of MVVM and Reactive paradigm</p>
<blockquote>
<p>Medium 原文 <a href="https://medium.com/flawless-app-stories/a-taste-of-mvvm-and-reactive-paradigm-5288a819cca1" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a><br> 原文博客 <a href="https://flawlessapp.io/blog/a-taste-of-mvvm-and-reactive-paradigm/" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a> </p>
</blockquote>
<p>我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。</p>
<p>我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自完成工作，他需要寻求帮助。举一个项目，例如，如果经理必须自己完成所有的工作，他会发疯的。因此需要组织和委派任务，并且需要许多人在项目上进行协作：设计师，测试人员，Scrum 主管，开发人员。任务完成后，需要通知经理。</p>
<p>这可能不是一个好例子。但至少你了解 OOP 中沟通和授权的重要性。当我开始 iOS 编程时，我对“架构”一词非常感兴趣。但在做了一段时间后，这一切都归结为识别和分担责任。本文讲述了 MVC 和 MVVM 的简单 Extract 类重构，以及如何进一步研究 Rx。您可以自由地创建自己的架构，但无论您做什么，一致性都是关键，不要让您的队友感到困惑或惊讶。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>看看你最熟悉的架构 - MVC，模型视图控制器的简称。 在新建一个 iOS 项目时总是会得到一个这样的架构。 View 是您使用 <code>UIView</code>，<code>UIButton</code>，<code>UILabel</code> 呈现数据的位置。 Model 只是数据的一个设想的词。 它可以是您的实体，来自网络的数据，来自数据库的对象或来自缓存。Controller 是在 Model 和 View 间进行调解的东西。<br><img src="/2019/06/26/mvvm【译】/1.jpg"></p>
<h3 id="宇宙中心-UIViewController"><a href="#宇宙中心-UIViewController" class="headerlink" title="宇宙中心 - UIViewController"></a>宇宙中心 - UIViewController</h3><p> <code>ViewController</code> 的问题在于它往往是巨大的。 Apple 把它作为宇宙的中心，它拥有许多属性和责任。你可以用 <code>UIViewController</code> 做很多事情。诸如与故事板交互，管理视图，配置视图轮换，状态恢复等事情。 <code>UIViewController</code> 设计了很多可以覆盖和自定义的方法。<br><a id="more"></a></p>
<p>看看 <code>UIViewController</code> <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller" target="_blank" rel="noopener">文档</a> 中的许多部分，如果没有 <code>UIViewController</code>，则无法执行以下操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func viewDidLoad()</span><br><span class="line">var preferredStatusBarStyle: UIStatusBarStyle &#123; get &#125;</span><br><span class="line">UITableViewDataSource</span><br><span class="line">var presentationController: UIPresentationController? &#123; get &#125;</span><br><span class="line">func childViewControllerForScreenEdgesDeferringSystemGestures() -&gt; UIViewController?</span><br><span class="line">func didMove(toParentViewController parent: UIViewController?)</span><br><span class="line">var systemMinimumLayoutMargins: NSDirectionalEdgeInsets</span><br><span class="line">var edgesForExtendedLayout: UIRectEdge</span><br><span class="line">var previewActionItems: [UIPreviewActionItem]</span><br><span class="line">var navigationItem: UINavigationItem</span><br><span class="line">var shouldAutorotate: Bool</span><br></pre></td></tr></table></figure>
<p>随着应用程序的增长，我们需要为其他逻辑添加更多代码。例如网络，数据源，处理多个代理，present 或 push 子视图控制器。当然，我们可以将所有内容放在视图控制器上，但这会产生出一个超大的 viewController.m 文件，这是很容易让你失去对 viewController 的把控，因为所有的东西都放在了这个巨型视图控制器中。你会倾向于引入重复的代码，并且修复错误变得很难，因为它们遍布各处。</p>
<p>Windows Phone 中的 <code>Page</code> 或 Android 中的 <code>Activity</code> 也是如此。它们用于屏幕或部分功能屏幕。某些操作只能通过它们完成，如 <a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.page.onnavigatedto%28v=vs.105%29.aspx" target="_blank" rel="noopener">Page.OnNavigatedTo</a> ，<a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.page.onnavigatedto%28v=vs.105%29.aspx" target="_blank" rel="noopener">Activity.onCreate</a> 。</p>
<h3 id="架构术语"><a href="#架构术语" class="headerlink" title="架构术语"></a>架构术语</h3><p>当 ViewController 做很多事情时你会怎么做？您将工作移到其他组件。顺便说一句，如果您希望其他对象执行用户输入处理，则可以使用 Presenter。如果 Presenter 做得太多，那么它可以将业务逻辑偏移到 Interactor。此外，还有更多架构术语可供使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let buzzWords = [</span><br><span class="line">  &quot;Model&quot;, &quot;View&quot;, &quot;Controller&quot;, &quot;Entity&quot;, &quot;Router&quot;, &quot;Clean&quot;, &quot;Reactive&quot;, </span><br><span class="line">  &quot;Presenter&quot;, &quot;Interactor&quot;, &quot;Megatron&quot;, &quot;Coordinator&quot;, &quot;Flow&quot;, &quot;Manager&quot;</span><br><span class="line">]</span><br><span class="line">let architecture = buzzWords.shuffled().takeRandom()</span><br><span class="line">let acronym = architecture.makeAcronym()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/26/mvvm【译】/2.jpg">
<p>在所有架构术语汇编完成后，我们得到了一个架构。<a href="https://github.com/onmyway133/fantastic-ios-architecture" target="_blank" rel="noopener">这里有更多</a>，包括简单的提取类重构，拥抱 MVC 或从 Clean Code，Rx，EventBus 或 Redux 中获取灵感。选择取决于项目，有些团队更喜欢这类架构而不是另一种架构。</p>
<h3 id="务实的程序员"><a href="#务实的程序员" class="headerlink" title="务实的程序员"></a>务实的程序员</h3><p>人们对什么是好的架构有不同的看法。对我来说，这是关于明确的关注分离，良好的沟通模式和使用舒适度。架构中的每个组件都应该是可识别的并且具有特定的角色。沟通必须清楚，以便我们知道哪个对象正在相互通信。这与良好的依赖注入一起使测试更容易。</p>
<p>理论上听起来不错的事情在实践中可能效果不佳。分离的域对象很酷，协议扩展很酷，多层抽象很酷。但是它们中可能有太多的问题。</p>
<p>如果你对设计模式有足够的了解，你就知道它们都归结为这些简单的原则：</p>
<ul>
<li>封装变化的内容：确定应用程序的各个方面的变化，并将它们与保持不变的方面分开。</li>
<li>编程到接口，而不是实现</li>
<li>更喜欢继承的组合</li>
</ul>
<p>如果我们要掌握一件事，那就是画结构图。关键是要确定责任，并以合理和一致的方式将其组成。向你的队友咨询最合适的，总是在编写代码的时候考虑到你也将是未来的维护者。然后你就会写得更好。</p>
<h3 id="不要和系统做斗争"><a href="#不要和系统做斗争" class="headerlink" title="不要和系统做斗争"></a>不要和系统做斗争</h3><p>一些架构引入了全新的范例。其中有些很麻烦，人们编写脚本来生成模板代码。有很多解决问题的方法是好的。但对我来说，有时候我觉得他们在与这个体系作斗争。有些任务很容易，而有些琐碎的任务则变得非常困难。我们不应该仅仅因为一个架构是时髦的，就把自己限制在一个架构中。要务实，不要武断。</p>
<p>在 iOS 中，我们应该接受 MVC。<code>UIViewController</code> 不适用于内容的全屏显示。它们可以拆分和组合达到拆分功能的目的。我们可以使用 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">Coordinator</a> 和 <a href="https://github.com/onmyway133/blog/issues/106" target="_blank" rel="noopener">FlowController</a> 来管理依赖关系和处理流。<a href="https://www.swiftbysundell.com/posts/custom-container-view-controllers-in-swift" target="_blank" rel="noopener">状态转换容器</a>，嵌入式逻辑<a href="https://www.swiftbysundell.com/posts/logic-controllers-in-swift" target="_blank" rel="noopener">控制器</a>，<a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-3-fixing-massive-view-controller/" target="_blank" rel="noopener">内容切分</a>。这种令人欣慰的 <code>ViewController</code> 方法在 iOS 中可以很好地与 MVC 配合使用，是我的首选方法。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><img src="/2019/06/26/mvvm【译】/3.jpg">
<p>另一个足够好的方法是将一些任务重定向到另一个对象，我们称之为 ViewModel 。这个名字不重要，你可以把它命名为反应堆，大师，恐龙。重要的是你的团队要有一个约定的名字。ViewModel 从 ViewController 中拆分一些任务，并在完成后告诉 ViewController。CocoaTouch 中有一些<a href="https://www.objc.io/issues/7-foundation/communication-patterns/" target="_blank" rel="noopener">通信模式</a>，例如要使用的委托、闭包。</p>
<p>ViewModel 是独立的，没有对 UIKit 的引用，只有输入和输出。我们可以把<a href="https://ashfurrow.com/blog/mvvm-is-exceptionally-ok/" target="_blank" rel="noopener">很多东西</a>放到 ViewModel 中，比如计算、格式化、联网、业务逻辑。此外，如果您不喜欢 ViewModel 变得庞大，那么您肯定需要创建一些专用的对象。ViewModel 是获得超薄 ViewController 的第一步。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>下面是一个非常简单的视图模型，它基于<code>用户</code>模型格式化数据，是同步进行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ProfileController: UIViewController &#123;</span><br><span class="line">  override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let viewModel = ViewModel(user: user)</span><br><span class="line">    nameLabel.text = viewModel.name</span><br><span class="line">    birthdayLabel.text = viewModel.birthdayString</span><br><span class="line">    salaryLabel.text = viewModel.salary</span><br><span class="line">    piLabel.text = viewModel.millionthDigitOfPi</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>我们一直在使用异步 API。如果我们想显示用户的 Facebook 好友数量呢？为了实现这一点，我们需要调用 Facebook  API，而这个操作需要时间。视图模型可以通过闭包进行报告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewModel.getFacebookFriends &#123; friends in</span><br><span class="line">  self.friendCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内部，ViewModel 可以将任务重定向到专用的 Facebook API 客户端对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  func getFacebookFriends(completion: [User] -&gt; Void) &#123;</span><br><span class="line">    let client = APIClient()</span><br><span class="line">    client.getFacebookFriends(for: user) &#123; friends in</span><br><span class="line">      DispatchQueue.main.async &#123;</span><br><span class="line">        completion(friends)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Android版Jetpack"><a href="#Android版Jetpack" class="headerlink" title="Android版Jetpack"></a>Android版Jetpack</h3><img src="/2019/06/26/mvvm【译】/4.jpg">
<p>谷歌在 2017 年的谷歌 IO 上推出了 Android 架构组件，现在是 Jetpack 的一部分。它有 ViewModel 和 LiveData ，这也是一种应用于 Android 的 MVVM 。ViewModel 通过配置更改存活下来，并根据要使用的活动的 LiveData 通知结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState, persistentState)</span><br><span class="line"></span><br><span class="line">        val model = ViewModelProviders.of(this).get(MyViewModel::class.java)</span><br><span class="line">        model.getUsers().observe(this, &#123; users -&gt;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是我喜欢 ViewModel 的原因之一。如果我们遵循这样的 ViewModel ，那么 iOS 和 Android 之间的代码结构就会变得相似。不需要一些随机的 JavaScript 跨平台解决方案。您只需学习一次这个概念，就可以将其应用到 iOS 和 Android 上。我在 iOS 上学习 ViewModel、RxSwift ，当我在 Android 上使用 RxJava 和 RxBinding 时，感觉就像在家一样。Kickstarter 项目也证明了这在 iOS 和 Android 应用程序中很好地工作。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>为了封装闭包，我们可以创建一个名为 Binding 的类，它可以通知一个或多个监听器。它利用了 <code>Didset</code> 的优点，使其可观测性变得清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Binding&lt;T&gt; &#123;</span><br><span class="line">  var value: T &#123;</span><br><span class="line">    didSet &#123;</span><br><span class="line">      listener?(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private var listener: ((T) -&gt; Void)?</span><br><span class="line">  init(value: T) &#123;</span><br><span class="line">    self.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  func bind(_ closure: @escaping (T) -&gt; Void) &#123;</span><br><span class="line">    closure(value)</span><br><span class="line">    listener = closure</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是如何在 ViewModel 中使用的 Binding 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  let friends = Binding&lt;[User]&gt;(value: [])</span><br><span class="line">  init() &#123;</span><br><span class="line">    getFacebookFriends &#123;</span><br><span class="line">      friends.value = $0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func getFacebookFriends(completion: ([User]) -&gt; Void) &#123;</span><br><span class="line">  	// Do the work</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论何时，当获取或更改 friends 时，ViewController 会相应地更新。这叫做对变化的反应。<br>你经常看到 MVVM 引入了反应式框架，这是有原因的。它们提供了许多链接操作符，并使反应式编程更容易和更具声明性。</p>
<h3 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h3><p>也许 Swift 中最常见的反应式框架是 RXSwift。我喜欢它的一点是它遵循了<a href="http://reactivex.io/" target="_blank" rel="noopener">响应式编程</a>模式。因此，如果您已经使用了 RxJava 、RxJS 或 RxKotlin ，您会感到更加熟悉。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><img src="/2019/06/26/mvvm【译】/5.jpg">
<p>RXSwift 通过 Observable 统一了同步和异步操作。你应该像下面这么做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  let friends: Observable&lt;[User]&gt;</span><br><span class="line">  init() &#123;</span><br><span class="line">    let client = APIClient()</span><br><span class="line">    friends = Observable&lt;[User]&gt;.create(&#123; subscriber in</span><br><span class="line">      client.getFacebookFriends(completion: &#123; friends in</span><br><span class="line">        subscriber.onNext(friends)</span><br><span class="line">        subscriber.onCompleted()</span><br><span class="line">      &#125;)</span><br><span class="line">      return Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RXSwift 的强大功能在于它的众多操作符，这些操作符可以帮助您链接可观察的对象。在这里，您可以调用 2 个网络请求，等待两个请求都完成，然后汇总 friends。这是非常流线型的，可以节省你很多时间。您可以在这里注册 Observable 监听，当请求完成时会触发它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  viewModel.friends.subscribe(onNext: &#123; friends in</span><br><span class="line">    self.friendsCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>ViewModel 和 RX 的一个优点是，我们可以使用 Observable 分离输入和输出，它提供了一个清晰的界面。点击阅读更多源码内容：<a href="https://github.com/onmyway133/blog/issues/87" target="_blank" rel="noopener"> Input and output container </a>。</p>
<p>下面很明显， fetch 是一个输入，而 friends 是可行的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  class Input &#123;</span><br><span class="line">    let fetch = PublishSubject&lt;()&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">  class Output &#123;</span><br><span class="line">    let friends: Driver&lt;[User]&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  let apiClient: APIClient</span><br><span class="line">  let input: Input</span><br><span class="line">  let output: Output</span><br><span class="line">  init(apiClient: APIClient) &#123;</span><br><span class="line">    self.apiClient = apiClient</span><br><span class="line">    // Connect input and output</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ProfileViewController: BaseViewController&lt;ProfileView&gt; &#123;</span><br><span class="line">  let viewModel: ProfileViewModelType</span><br><span class="line">  init(viewModel: ProfileViewModelType) &#123;</span><br><span class="line">    self.viewModel = viewModel</span><br><span class="line">  &#125;</span><br><span class="line">  override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    // Input</span><br><span class="line">    viewModel.input.fetch.onNext(())</span><br><span class="line">    // Output</span><br><span class="line">    viewModel.output.friends.subscribe(onNext: &#123; friends in</span><br><span class="line">      self.friendsCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reactive-如何工作"><a href="#reactive-如何工作" class="headerlink" title="reactive 如何工作"></a>reactive 如何工作</h3><p>如果你喜欢 Rx ，在使用一些框架一段时间后，了解它们是很好的。有一些概念，如 <code>Signal</code>, <code>SignalProducer</code>, <code>Observable</code>, <code>Promise</code>, <code>Future</code>, <code>Task</code>, <code>Job</code>, <code>Launcher</code>, <code>Async</code>，有些人对它们可以有很好的区分。在这里，我简单地称之为 <code>Signal</code>，它是一种可以发出信号值的东西。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p><code>Signal</code> 及其 <code>Result</code> 只是 <a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">Monads</a> ，它是可以被映射和链接的东西。</p>
<p><code>Signal</code> 使用延迟的执行回调闭包。它可以获取或推送。这就是 <code>Signal</code> 更新值和调用回调的顺序的方式。</p>
<p>执行回调方法意味着我们将一个函数传递给另一个函数。传入函数在适当的时候被调用。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>Monad 可以是同步模式或异步模式。同步更容易理解，但异步在实践中已经很熟悉和使用了。</p>
<ul>
<li>同步：通过返回立即得到返回值</li>
<li>异步：通过回调块得到返回值</li>
</ul>
<p>下面是一个简单的同步和异步自由函数示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Sync</span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Async</span><br><span class="line">func sum(a: Int, b: Int, completion: Int -&gt; Void) &#123;</span><br><span class="line">    // Assumed it is a very long task to get the result</span><br><span class="line">    let result = a + b</span><br><span class="line"></span><br><span class="line">    completion(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及同步和异步如何应用于返回值类型。注意异步版本，我们在一个完成闭包中得到转换值，而不是从函数立即返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T&gt; &#123;</span><br><span class="line">  case value(value: T)</span><br><span class="line">  case failure(error: Error)</span><br><span class="line"></span><br><span class="line">  // Sync</span><br><span class="line">  public func map&lt;U&gt;(f: (T) -&gt; U) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case let .value(value):</span><br><span class="line">      return .value(value: f(value))</span><br><span class="line">    case let .failure(error):</span><br><span class="line">      return .failure(error: error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Async</span><br><span class="line">  public func map&lt;U&gt;(f: @escaping ((T), (U) -&gt; Void) -&gt; Void) -&gt; (((Result&lt;U&gt;) -&gt; Void) -&gt; Void) &#123;</span><br><span class="line">    return &#123; g in   // g: Result&lt;U&gt; -&gt; Void</span><br><span class="line">      switch self &#123;</span><br><span class="line">      case let .value(value):</span><br><span class="line">        f(value) &#123; transformedValue in  // transformedValue: U</span><br><span class="line">          g(.value(value: transformedValue))</span><br><span class="line">        &#125;</span><br><span class="line">      case let .failure(error):</span><br><span class="line">        g(.failure(error: error))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推送信号"><a href="#推送信号" class="headerlink" title="推送信号"></a>推送信号</h3><p>给出这样一个信号链：<br><code>A -(map)-&gt; B -(flatMap)-&gt; C -(flatMap)-&gt; D -(subscribe)</code><br>推送信号，当 信号A 在一个事件发生时，它通过 CallBacks 事件传播。<code>PushSignal</code> 在 RxSwift 中类似于 <code>PublishSubject</code>。</p>
<ul>
<li>通过向源信号发送事件触发。</li>
<li>我们必须保持 A，因为它使其信号保持</li>
<li>我们订阅最后一个 D</li>
<li>我们将事件发送到第一个 A</li>
<li>A 的回调被调用，它依次使用 A 的映射结果调用 B 的回调，然后 B 的回调使用 B 的平面映射结果调用 C 的回调，依此类推。</li>
</ul>
<p>它类似于 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a> ，您可以在我的 <a href="https://github.com/onmyway133/Then/blob/master/Pod/Classes/Promise.swift" target="_blank" rel="noopener">Then framework</a> 中看到 Promise A+ 的 Swift 实现。现在，这里是一个简单的 <code>PushSignal</code> 的 Swift 4 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public final class PushSignal&lt;T&gt; &#123;</span><br><span class="line">  var event: Result&lt;T&gt;?</span><br><span class="line">  var callbacks: [(Result&lt;T&gt;) -&gt; Void] = []</span><br><span class="line">  let lockQueue = DispatchQueue(label: &quot;Serial Queue&quot;)</span><br><span class="line"></span><br><span class="line">  func notify() &#123;</span><br><span class="line">    guard let event = event else &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callbacks.forEach &#123; callback in</span><br><span class="line">      callback(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func update(event: Result&lt;T&gt;) &#123;</span><br><span class="line">    lockQueue.sync &#123;</span><br><span class="line">      self.event = event</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func subscribe(f: @escaping (Result&lt;T&gt;) -&gt; Void) -&gt; Signal&lt;T&gt; &#123;</span><br><span class="line">    // Callback</span><br><span class="line">    if let event = event &#123;</span><br><span class="line">      f(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callbacks.append(f)</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func map&lt;U&gt;(f: @escaping (T) -&gt; U) -&gt; Signal&lt;U&gt; &#123;</span><br><span class="line">    let signal = Signal&lt;U&gt;()</span><br><span class="line"></span><br><span class="line">    _ = subscribe &#123; event in</span><br><span class="line">      signal.update(event: event.map(f: f))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return signal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是如何使用 PushSignal 将链从字符串转换为其长度，您应该看到 4，即打印的字符串 “test” 的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let signal = PushSignal&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">_ = signal.map &#123; value in</span><br><span class="line">  return value.count</span><br><span class="line">&#125;.subscribe &#123; event in</span><br><span class="line">  if case let .value(value) = event &#123;</span><br><span class="line">    print(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print(&quot;error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal.update(event: .value(value: &quot;test&quot;))</span><br></pre></td></tr></table></figure>
<h3 id="获取信号"><a href="#获取信号" class="headerlink" title="获取信号"></a>获取信号</h3><p>给出这样一个信号链：<br><code>A -(map)-&gt; B -(flatMap)-&gt; C -(flatMap)-&gt; D -(subscribe)</code></p>
<p>获取信号，有时称为 Future，意味着当我们订阅最终的信号 D 时，它会导致先前的信号被激活：</p>
<ul>
<li>通过订阅最终信号 D 触发；</li>
<li>我们必须保持 D，因为它使其信号保持</li>
<li>我们订阅最后一个 D</li>
<li>D 的操作运行，它导致 C 的操作运行，… 然后 A 的操作运行。执行任务（如获取网络、检索数据库、文件访问、大量计算等）以获取结果，并调用A的完成。然后，A 的完成调用 B 的完成，结果由 B 的映射映射，…一直映射到订阅方的完成 block。</li>
</ul>
<p>这里是 PullSignal 的一个 Swift 4 实现。PullSignal 类似于 Rxswift 中的 Observable 和 ReactiveSwift 中的SignalProducer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public struct PullSignal&lt;T&gt; &#123;</span><br><span class="line">  let operation: ((Result&lt;T&gt;) -&gt; Void) -&gt; Void</span><br><span class="line"></span><br><span class="line">  public init(operation: @escaping ((Result&lt;T&gt;) -&gt; Void) -&gt; Void) &#123;</span><br><span class="line">    self.operation = operation</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func start(completion: (Result&lt;T&gt;) -&gt; Void) &#123;</span><br><span class="line">    operation() &#123; event in</span><br><span class="line">      completion(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func map&lt;U&gt;(f: @escaping (T) -&gt; U) -&gt; PullSignal&lt;U&gt; &#123;</span><br><span class="line">    return PullSignal&lt;U&gt; &#123; completion in</span><br><span class="line">      self.start &#123; event in</span><br><span class="line">        completion(event.map(f: f))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链是不活动的，直到您调用链中的最后一个信号开始，这将触发操作流到第一个信号。运行这个代码，您应该看到 4 ，控制台上打印的字符串 “test” 的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let signal = PullSignal&lt;String&gt; &#123; completion in</span><br><span class="line">  // There should be some long running operation here</span><br><span class="line">  completion(Result.value(value: &quot;test&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal.map &#123; value in</span><br><span class="line">  value.count</span><br><span class="line">&#125;.start &#123; event in</span><br><span class="line">  if case let .value(value) = event &#123;</span><br><span class="line">    print(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print(&quot;error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我希望这些代码段足够简单，能够帮助您理解信号在后台是如何工作的，以及如何区分冷热信号。为了得到一个完全工作的信号框架，您需要实现更多的操作。如 <code>retry</code> , <code>rebounce</code> , <code>throttle</code> , <code>queue</code> , <code>flatten</code>, <code>filter</code>, <code>delay</code>, <code>combine</code> 和添加 UIKit 支持，就像 RxCocoa 所做的，具体可以在我的 <a href="https://github.com/onmyway133/archives/tree/master/Signal/Pod/Classes" target="_blank" rel="noopener">Signal repo</a> 中查看实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>架构是一个非常常见的话题。希望这篇文章能给您的决策带来一些想法。MVC 在 iOS 中占主导地位，MVVM 是一个好朋友，RX 是一个强大的工具。以下是一些更有趣的读物：</p>
<ul>
<li><a href="https://ashfurrow.com/blog/mvvm-is-exceptionally-ok/" target="_blank" rel="noopener">MVVM is Exceptionally OK</a></li>
<li><a href="https://academy.realm.io/posts/krzysztof-zablocki-mDevCamp-ios-architecture-mvvm-mvc-viper/" target="_blank" rel="noopener">Good iOS Application Architecture: MVVM vs. MVC vs. VIPER</a></li>
<li><a href="https://www.youtube.com/watch?v=YWVzCd5FYbs" target="_blank" rel="noopener">A Better MVC</a></li>
<li><a href="https://blog.uptech.team/taming-great-complexity-mvvm-coordinators-and-rxswift-8daf8a76e7fd" target="_blank" rel="noopener">Taming Great Complexity: MVVM, Coordinators and RxSwift</a></li>
<li><a href="http://blogs.microsoft.co.il/bnaya/2010/03/13/rx-for-beginners-part-9-hot-vs-cold-observable/" target="_blank" rel="noopener">Rx — for beginners (part 9): Hot Vs. Cold observable</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md" target="_blank" rel="noopener">Hot and Cold Observables</a></li>
<li><a href="https://stackoverflow.com/questions/17082255/when-to-use-ienumerable-vs-iobservable" target="_blank" rel="noopener">When to use IEnumerable vs IObservable?</a></li>
<li><a href="https://www.youtube.com/watch?v=AcDaWe3S75c" target="_blank" rel="noopener">Functional Reactive Programming without Black Magic</a></li>
<li><a href="https://www.youtube.com/watch?v=mbd6g7NfR-8" target="_blank" rel="noopener">Swift Sync and Async Error Handling</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>【译】A taste of MVVM and Reactive paradigm</p>
<blockquote>
<p>Medium 原文 <a href="https://medium.com/flawless-app-stories/a-taste-of-mvvm-and-reactive-paradigm-5288a819cca1" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a><br> 原文博客 <a href="https://flawlessapp.io/blog/a-taste-of-mvvm-and-reactive-paradigm/" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a> </p>
</blockquote>
<p>我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。</p>
<p>我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自完成工作，他需要寻求帮助。举一个项目，例如，如果经理必须自己完成所有的工作，他会发疯的。因此需要组织和委派任务，并且需要许多人在项目上进行协作：设计师，测试人员，Scrum 主管，开发人员。任务完成后，需要通知经理。</p>
<p>这可能不是一个好例子。但至少你了解 OOP 中沟通和授权的重要性。当我开始 iOS 编程时，我对“架构”一词非常感兴趣。但在做了一段时间后，这一切都归结为识别和分担责任。本文讲述了 MVC 和 MVVM 的简单 Extract 类重构，以及如何进一步研究 Rx。您可以自由地创建自己的架构，但无论您做什么，一致性都是关键，不要让您的队友感到困惑或惊讶。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>看看你最熟悉的架构 - MVC，模型视图控制器的简称。 在新建一个 iOS 项目时总是会得到一个这样的架构。 View 是您使用 <code>UIView</code>，<code>UIButton</code>，<code>UILabel</code> 呈现数据的位置。 Model 只是数据的一个设想的词。 它可以是您的实体，来自网络的数据，来自数据库的对象或来自缓存。Controller 是在 Model 和 View 间进行调解的东西。<br><img src="/2019/06/26/mvvm【译】/1.jpg"></p>
<h3 id="宇宙中心-UIViewController"><a href="#宇宙中心-UIViewController" class="headerlink" title="宇宙中心 - UIViewController"></a>宇宙中心 - UIViewController</h3><p> <code>ViewController</code> 的问题在于它往往是巨大的。 Apple 把它作为宇宙的中心，它拥有许多属性和责任。你可以用 <code>UIViewController</code> 做很多事情。诸如与故事板交互，管理视图，配置视图轮换，状态恢复等事情。 <code>UIViewController</code> 设计了很多可以覆盖和自定义的方法。<br></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[app 加载过程 & 启动速度优化]]></title>
    <link href="http://yoursite.com/2019/02/26/app-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/26/app-加载过程/</id>
    <published>2019-02-25T18:21:33.000Z</published>
    <updated>2019-07-16T07:45:23.606Z</updated>
    <content type="html"><![CDATA[<p>上篇文章介绍了 MachO 文件的结构，你可能注意到其中的 LC_LOAD_DYLINKER 是 dyld， LC_MAIN 加载命令就是加载程序的主入口。这篇文章就详细讲讲 App 的加载过程。</p>
<h4 id="MachO-可执行文件类型"><a href="#MachO-可执行文件类型" class="headerlink" title="MachO 可执行文件类型"></a>MachO 可执行文件类型</h4><p>Xcode build 出的 .app 包中可以看到一个 exec 可执行文件（所有 .o文件集合），同样是一个 MachO 文件，filetype 就是 MH_EXECUTE 类型。<br>MachOView中查看如下。<br><img src="/2019/02/26/app-加载过程/exec.png" title="&nbsp;"><br><a id="more"></a></p>
<h4 id="link-map"><a href="#link-map" class="headerlink" title="link map"></a>link map</h4><p>MachO 中重要的信息都在 Section 中。<br>可以通过 Xcode 开启 Write Link Map File = YES 后生成的 txt 文件来辅助分析 Section。可以帮助你更好的了解 App 的加载。<br><img src="/2019/02/26/app-加载过程/text_text.png" title="&nbsp;"></p>
<h5 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h5><p>这个部分包括的内容如下：</p>
<blockquote>
<p>.o文件，也就是.m文件编译后的结果。<br>.a文件<br>需要link的framework<br>前面是文件的编号（section中用到），后面是文件的路径。</p>
</blockquote>
<h5 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h5><p>这个区域提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小。这个区域完整的描述克可执行文件中的全部内容，对应 MachO 的 segment 和 section<br>其中，段分为两种<br><code>__TEXT</code> 代码段<br><code>__DATA</code> 数据段<br><code>__text</code>节的地址是0x100001A50，大小是0x0002436D，二者相加的就是<code>__stubs</code>的位置0x100025DBE。</p>
<h5 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h5><p>Section 部分将二进制文件进行了一级划分。而，Symbols 对 Section 中的各个段进行了二级划分，</p>
<p>例如，对于<code>__TEXT __text</code>,表示代码段中的代码内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line">地址     	大小         文件编号  方法名</span><br><span class="line"># Address	Size    	File  	Name</span><br><span class="line">0x100001A50	0x00000120	[  2] -[EasyViewController sectionSource]</span><br><span class="line">0x100001B70	0x00001720	[  2] -[EasyViewController dataSource]</span><br><span class="line">0x100003290	0x00000610	[  2] -[EasyViewController viewDidLoad]</span><br><span class="line">0x1000038A0	0x00000080	[  2] -[EasyViewController viewDidAppear:]</span><br><span class="line">0x100003920	0x00000300	[  2] -[EasyViewController viewWillAppear:]</span><br><span class="line">...</span><br><span class="line">0x100025A60	0x0000035D	[ 17] _parseSystemVersionPList</span><br><span class="line">0x100025DBE	0x00000006	[ 18] _CFRunLoopAddObserver // 这里开始是__stubs</span><br></pre></td></tr></table></figure><br><code>__Text __stubs</code></p>
<p>对于<code>__Data __objc_var</code><br>搜索 0x100036F60 可以找到如下信息<br><img src="/2019/02/26/app-加载过程/var.png" title="&nbsp;"></p>
<p>我们在每次编译过后，生成的 dsym 中，就存储了16进制的函数地址映射。可以通过 MachoView 查看 SymbolString。SymbolString包含了方法段的启始地址。<br><img src="/2019/02/26/app-加载过程/symbolString.png" title="&nbsp;"><br><code>_DWARF __debbug_line</code>中存储了行号信息<br><code>_DWARF __debbug_info</code> 和 <code>_DWARF __debbug_frame</code> dwarf-dump –lookup 就是通过 SymbolString 和  <code>__debbug_line</code> 和 <code>_DWARF __debbug_info</code>等信息来获取崩溃信息。<br><img src="/2019/02/26/app-加载过程/dwarf_line.png" title="&nbsp;"><br>实际测试还需要进一步对 DWARF 格式有更多的了解，后续再说。</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p>App开始启动后，系统首先加载可执行文件 （所有 .o 文件集合）,然后加载动态链接库 dyld，dyld是一个专门用来加载动态链接库的库，递归加载所有的依赖动态链接库。<br>动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，CoreFoundation等。<br>系统使用动态链接的好处：</p>
<ul>
<li>代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份，方便缓存。</li>
<li>易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新<br>dyld(the dynamic link editor), Apple 的动态链接器，所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应）.</li>
</ul>
<p>dyld 加载动态链接库的流程有：</p>
<ul>
<li>load dylibs image 读取库镜像文件: 分析所依赖的动态库 -&gt; 找到动态库 MachO 文件 -&gt; 读取 MachO 文件 -&gt; 通过UUID验证文件- -&gt;注册文件签名 -&gt; 调用Segment<br>启动优化: <blockquote>
<p>少非系统库的依赖<br>合并非系统库<br>使用静态库，比如把代码加入主程序</p>
</blockquote>
</li>
<li>Rebase image &amp; Bind image： ASLR(address space layout randomization 地址空间随机化，每个macho都随机了一个slide)使得可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，之所以需要Rebase，是因为刚刚提到的 ASLR 使得地址随机化，导致起始地址不固定，另外由于Code Sign，导致不能直接修改Image。Rebase的时候只需要增加对应的偏移量即可。待Rebase的数据都存放在<code>__LINKEDIT</code> 中。可以通过MachOView查看：Dynamic Loader Info -&gt; Rebase Info<br>rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。  rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算.<br>优化：<blockquote>
<p>减少Objc类数量， 减少selector数量<br>减少C++虚函数数量<br>加载完macho和动态链接库和进行了地址修正之后,dyld所做的事情完成了大部分.</p>
</blockquote>
</li>
<li>Objc setup : dyld 回调 Objc Runtime，执行Setup<blockquote>
<p>从 <code>_DATA __objc_classlist</code> 段中获取类信息，注册Objc到一个全局的类的映射表中。<br>从 <code>_DATA __objc_protolist</code> 段中获取中获取Protocol、category等属性与类进行关联，把category的定义插入方法列表 (category registration)<br>保证每一个selector唯一 (selctor uniquing)</p>
</blockquote>
</li>
<li><p>nitializers<br>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 </p>
<blockquote>
<p>执行+load方法，循环类和类扩展列表调用+load方法<br>执行c/c++初始化构造器, 如attribute((constructor)) void SomeInitializationWork()<br>初始化全局静态变量,非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度<br>优化：<br>不是必须在 +load方法中执行的任务放到initialize中<br>减少不必要的全局静态变量</p>
</blockquote>
</li>
<li><p>通过可执行文件的 LC_MAIN ，拿到entryoff 再加上MachO的首地址（内核传来的slide偏移）就得到了main函数地址。</p>
</li>
</ul>
<p>主要流程总结</p>
<blockquote>
<p>dyld 开始将程序二进制文件初始化<br>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号<br>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理<br>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法<br>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p>
</blockquote>
<p>参考文章:<br><a href="https://techblog.toutiao.com/2018/05/29/untitled-24/?from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">【性能优化】iOS客户端启动速度优化</a><br><a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863" target="_blank" rel="noopener">深入理解iOS App的启动过程</a><br><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/" target="_blank" rel="noopener">dyld与ObjC</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇文章介绍了 MachO 文件的结构，你可能注意到其中的 LC_LOAD_DYLINKER 是 dyld， LC_MAIN 加载命令就是加载程序的主入口。这篇文章就详细讲讲 App 的加载过程。</p>
<h4 id="MachO-可执行文件类型"><a href="#MachO-可执行文件类型" class="headerlink" title="MachO 可执行文件类型"></a>MachO 可执行文件类型</h4><p>Xcode build 出的 .app 包中可以看到一个 exec 可执行文件（所有 .o文件集合），同样是一个 MachO 文件，filetype 就是 MH_EXECUTE 类型。<br>MachOView中查看如下。<br><img src="/2019/02/26/app-加载过程/exec.png" title="&nbsp;"><br></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MachO 文件结构分析]]></title>
    <link href="http://yoursite.com/2019/02/24/macho-analysis/"/>
    <id>http://yoursite.com/2019/02/24/macho-analysis/</id>
    <published>2019-02-23T17:53:35.000Z</published>
    <updated>2019-07-02T08:29:03.421Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章中提到了如何自建一个 Crash 平台，其中通过对系统库 (MachO) 的结构解析来寻找崩溃符号。这篇文章就具体讲讲 MachO 文件的结构分析。</p>
<p>iOS中，我们平时看见的 MachO 文件你肯定不陌生，包括静态库(.a)、dSym (yourAppName.dSym)、系统动态库 (/usr/lib/libobjc.A.dylib)、可执行文件等。具体类型下面会讲到。</p>
<p>MachO 二进制文件可以根据前四字节的magic_num来判断是不是 Fat (包含一个或多个架构，有 Fat_Header), 每个架构同样是的 MachO文件。可以这样比喻，相当于对一个或多个文件用文件夹压缩了下。zip 包相当于 Fat，文件是 Thin。每个文件的内部结构式一致的。</p>
<h4 id="Fat"><a href="#Fat" class="headerlink" title="Fat"></a>Fat</h4><img src="/2019/02/24/macho-analysis/fat.png" title="&nbsp;">
<p>可以看到 Fat 多了 Fat_Header信息, 信息中包含架构数，每个架构的基本信息。<br>Fat 可以通过lipo -thin 命令分解出 thin。 thin 也可以合并成 Fat。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分解</span><br><span class="line">lipo BICrashAnalyzeDemo -thin arm64 -output crashAnalyzeDemoARM64</span><br><span class="line">lipo BICrashAnalyzeDemo -thin armv7 -output crashAnalyzeDemoARMV7</span><br><span class="line">//合并</span><br><span class="line">lipo crashAnalyzeDemoARM64 crashAnalyzeDemoARMV7 -create -output BICrashAnalyzeDemo</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="Thin"><a href="#Thin" class="headerlink" title="Thin"></a>Thin</h4><img src="/2019/02/24/macho-analysis/thin.png" title="&nbsp;">
<p>所以我们只需要了解Thin的 MachO 文件内部结构。<br>macho大致结构如下:<br><img src="/2019/02/24/macho-analysis/macho.jpg" title="&nbsp;"></p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>macho 文件的大致信息，包含文件类型、32位还是64（MH_MAGIC_64）、架构、lc 个数，lc 大小<br><img src="/2019/02/24/macho-analysis/header.png" title="&nbsp;"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">	uint32_t	magic;		/* mach magic number identifier */</span><br><span class="line">	cpu_type_t	cputype;	/* cpu specifier */</span><br><span class="line">	cpu_subtype_t	cpusubtype;	/* machine specifier */</span><br><span class="line">	uint32_t	filetype;	/* type of file */</span><br><span class="line">	uint32_t	ncmds;		/* number of load commands */</span><br><span class="line">	uint32_t	sizeofcmds;	/* the size of all the load commands */</span><br><span class="line">	uint32_t	flags;		/* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="/2019/02/24/macho-analysis/headercode.png" title="&nbsp;"></p>
<ul>
<li>magic：MachO文件的魔数，用来确定其属于64位（0xfeedfacf/MH_MAGIC_64）还是32位（0xfeedface/MH_MAGIC），分别对应的是arm64和 armv7的Header。</li>
<li>cputype和cupsubtype代表的是cpu的类型和其子类型，定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_TYPE_ARM ((cpu_type_t)12)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t)6)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t)9)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t)11)</span><br><span class="line"></span><br><span class="line">#define CPU_TYPE_ARM64 ((cpu_type_t)16777228)</span><br><span class="line">#define CPU_SUBTYPE_ARM64_ALL ((cpu_subtype_t)0)</span><br><span class="line"></span><br><span class="line">#define CPU_TYPE_I386 ((cpu_type_t)7)</span><br><span class="line">#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>filetype 上面提到的 filetype，例子中为 dSym<br>可以看到苹果源文件中包含的所有类型。类型包含在 MachO 的 mach_header(_64) 的filetype字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> *</span><br><span class="line"> * Constants for the filetype field of the mach_header</span><br><span class="line"> */</span><br><span class="line">#define	MH_OBJECT	0x1		/* relocatable object file */可重定位的目标文件，编译器对源代码编译得到的中间结果。如gcc-c生成的</span><br><span class="line">#define	MH_EXECUTE	0x2		/* demand paged executable file */ 可执行文件(应用程序生成的二进制文件)，</span><br><span class="line">#define	MH_FVMLIB	0x3		/* fixed VM shared library file */</span><br><span class="line">#define	MH_CORE		0x4		/* core file */</span><br><span class="line">#define	MH_PRELOAD	0x5		/* preloaded executable file */</span><br><span class="line">#define	MH_DYLIB	0x6		/* dynamically bound shared library */ 动态库</span><br><span class="line">#define	MH_DYLINKER	0x7		/* dynamic link editor */ 动态链接库</span><br><span class="line">#define	MH_BUNDLE	0x8		/* dynamically bound bundle file */</span><br><span class="line">#define	MH_DYLIB_STUB	0x9		/* shared library stub for static */ </span><br><span class="line">					/*  linking only, no section contents */</span><br><span class="line">#define	MH_DSYM		0xa		/* companion file with only debug */ dSym 文件 gcc-g生成</span><br><span class="line">					/*  sections */</span><br><span class="line">#define	MH_KEXT_BUNDLE	0xb		/* x86_64 kexts */ 64位内核扩展</span><br></pre></td></tr></table></figure>
</li>
<li><p>ncmds  load command 个数</p>
</li>
<li>sizeofcmds 所有 load command 大小</li>
<li>flags 执行相关的一些设置，用途如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#define	MH_NOUNDEFS	0x1		/* the object file has no undefined</span><br><span class="line">					   references */</span><br><span class="line">#define	MH_INCRLINK	0x2		/* the object file is the output of an</span><br><span class="line">					   incremental link against a base file</span><br><span class="line">					   and can&apos;t be link edited again */</span><br><span class="line">#define MH_DYLDLINK	0x4		/* the object file is input for the</span><br><span class="line">					   dynamic linker and can&apos;t be staticly</span><br><span class="line">					   link edited again */</span><br><span class="line">#define MH_BINDATLOAD	0x8		/* the object file&apos;s undefined</span><br><span class="line">					   references are bound by the dynamic</span><br><span class="line">					   linker when loaded. */</span><br><span class="line">#define MH_PREBOUND	0x10		/* the file has its dynamic undefined</span><br><span class="line">					   references prebound. */</span><br><span class="line">#define MH_SPLIT_SEGS	0x20		/* the file has its read-only and</span><br><span class="line">					   read-write segments split */</span><br><span class="line">#define MH_LAZY_INIT	0x40		/* the shared library init routine is</span><br><span class="line">					   to be run lazily via catching memory</span><br><span class="line">					   faults to its writeable segments</span><br><span class="line">					   (obsolete) */</span><br><span class="line">#define MH_TWOLEVEL	0x80		/* the image is using two-level name</span><br><span class="line">					   space bindings */</span><br><span class="line">#define MH_FORCE_FLAT	0x100		/* the executable is forcing all images</span><br><span class="line">					   to use flat name space bindings */</span><br><span class="line">#define MH_NOMULTIDEFS	0x200		/* this umbrella guarantees no multiple</span><br><span class="line">					   defintions of symbols in its</span><br><span class="line">					   sub-images so the two-level namespace</span><br><span class="line">					   hints can always be used. */</span><br><span class="line">#define MH_NOFIXPREBINDING 0x400	/* do not have dyld notify the</span><br><span class="line">					   prebinding agent about this</span><br><span class="line">					   executable */</span><br><span class="line">#define MH_PREBINDABLE  0x800           /* the binary is not prebound but can</span><br><span class="line">					   have its prebinding redone. only used</span><br><span class="line">                                           when MH_PREBOUND is not set. */</span><br><span class="line">#define MH_ALLMODSBOUND 0x1000		/* indicates that this binary binds to</span><br><span class="line">                                           all two-level namespace modules of</span><br><span class="line">					   its dependent libraries. only used</span><br><span class="line">					   when MH_PREBINDABLE and MH_TWOLEVEL</span><br><span class="line">					   are both set. */ </span><br><span class="line">#define MH_SUBSECTIONS_VIA_SYMBOLS 0x2000/* safe to divide up the sections into</span><br><span class="line">					    sub-sections via symbols for dead</span><br><span class="line">					    code stripping */</span><br><span class="line">#define MH_CANONICAL    0x4000		/* the binary has been canonicalized</span><br><span class="line">					   via the unprebind operation */</span><br><span class="line">#define MH_WEAK_DEFINES	0x8000		/* the final linked image contains</span><br><span class="line">					   external weak symbols */</span><br><span class="line">#define MH_BINDS_TO_WEAK 0x10000	/* the final linked image uses</span><br><span class="line">					   weak symbols */</span><br><span class="line"></span><br><span class="line">#define MH_ALLOW_STACK_EXECUTION 0x20000/* When this bit is set, all stacks </span><br><span class="line">					   in the task will be given stack</span><br><span class="line">					   execution privilege.  Only used in</span><br><span class="line">					   MH_EXECUTE filetypes. */</span><br><span class="line">#define MH_ROOT_SAFE 0x40000           /* When this bit is set, the binary </span><br><span class="line">					  declares it is safe for use in</span><br><span class="line">					  processes with uid zero */</span><br><span class="line">                                         </span><br><span class="line">#define MH_SETUID_SAFE 0x80000         /* When this bit is set, the binary </span><br><span class="line">					  declares it is safe for use in</span><br><span class="line">					  processes when issetugid() is true */</span><br><span class="line"></span><br><span class="line">#define MH_NO_REEXPORTED_DYLIBS 0x100000 /* When this bit is set on a dylib, </span><br><span class="line">					  the static linker does not need to</span><br><span class="line">					  examine dependent dylibs to see</span><br><span class="line">					  if any are re-exported */</span><br><span class="line">#define	MH_PIE 0x200000			/* When this bit is set, the OS will</span><br><span class="line">					   load the main executable at a</span><br><span class="line">					   random address.  Only used in</span><br><span class="line">					   MH_EXECUTE filetypes. */</span><br><span class="line">#define	MH_DEAD_STRIPPABLE_DYLIB 0x400000 /* Only for use on dylibs.  When</span><br><span class="line">					     linking against a dylib that</span><br><span class="line">					     has this bit set, the static linker</span><br><span class="line">					     will automatically not create a</span><br><span class="line">					     LC_LOAD_DYLIB load command to the</span><br><span class="line">					     dylib if no symbols are being</span><br><span class="line">					     referenced from the dylib. */</span><br><span class="line">#define MH_HAS_TLV_DESCRIPTORS 0x800000 /* Contains a section of type </span><br><span class="line">					    S_THREAD_LOCAL_VARIABLES */</span><br><span class="line"></span><br><span class="line">#define MH_NO_HEAP_EXECUTION 0x1000000	/* When this bit is set, the OS will</span><br><span class="line">					   run the main executable with</span><br><span class="line">					   a non-executable heap even on</span><br><span class="line">					   platforms (e.g. i386) that don&apos;t</span><br><span class="line">					   require it. Only used in MH_EXECUTE</span><br><span class="line">					   filetypes. */</span><br></pre></td></tr></table></figure>
用途<img src="/2019/02/24/macho-analysis/flags.jpg" title="&nbsp;">
</li>
</ul>
<h4 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h4><p>用于告诉loader如何设置并加载二进制数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//基本信息</span><br><span class="line">struct load_command &#123;</span><br><span class="line">	uint32_t cmd;		/* type of load command */</span><br><span class="line">	uint32_t cmdsize;	/* total size of command in bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>cmd类型有很多，查看 loader.h中的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * After MacOS X 10.1 when a new load command is added that is required to be</span><br><span class="line"> * understood by the dynamic linker for the image to execute properly the</span><br><span class="line"> * LC_REQ_DYLD bit will be or&apos;ed into the load command constant.  If the dynamic</span><br><span class="line"> * linker sees such a load command it it does not understand will issue a</span><br><span class="line"> * &quot;unknown load command required for execution&quot; error and refuse to use the</span><br><span class="line"> * image.  Other load commands without this bit that are not understood will</span><br><span class="line"> * simply be ignored.</span><br><span class="line"> */</span><br><span class="line">#define LC_REQ_DYLD 0x80000000</span><br><span class="line"></span><br><span class="line">/* Constants for the cmd field of all load commands, the type */</span><br><span class="line">#define	LC_SEGMENT	0x1	/* segment of this file to be mapped */ </span><br><span class="line">#define	LC_SYMTAB	0x2	/* link-edit stab symbol table info */</span><br><span class="line">#define	LC_SYMSEG	0x3	/* link-edit gdb symbol table info (obsolete) */</span><br><span class="line">#define	LC_THREAD	0x4	/* thread */</span><br><span class="line">#define	LC_UNIXTHREAD	0x5	/* unix thread (includes a stack) */</span><br><span class="line">#define	LC_LOADFVMLIB	0x6	/* load a specified fixed VM shared library */</span><br><span class="line">#define	LC_IDFVMLIB	0x7	/* fixed VM shared library identification */</span><br><span class="line">#define	LC_IDENT	0x8	/* object identification info (obsolete) */</span><br><span class="line">#define LC_FVMFILE	0x9	/* fixed VM file inclusion (internal use) */</span><br><span class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</span><br><span class="line">#define	LC_DYSYMTAB	0xb	/* dynamic link-edit symbol table info */</span><br><span class="line">#define	LC_LOAD_DYLIB	0xc	/* load a dynamically linked shared library */</span><br><span class="line">#define	LC_ID_DYLIB	0xd	/* dynamically linked shared lib ident */</span><br><span class="line">#define LC_LOAD_DYLINKER 0xe	/* load a dynamic linker */</span><br><span class="line">#define LC_ID_DYLINKER	0xf	/* dynamic linker identification */</span><br><span class="line">#define	LC_PREBOUND_DYLIB 0x10	/* modules prebound for a dynamically */</span><br><span class="line">				/*  linked shared library */</span><br><span class="line">#define	LC_ROUTINES	0x11	/* image routines */</span><br><span class="line">#define	LC_SUB_FRAMEWORK 0x12	/* sub framework */</span><br><span class="line">#define	LC_SUB_UMBRELLA 0x13	/* sub umbrella */</span><br><span class="line">#define	LC_SUB_CLIENT	0x14	/* sub client */</span><br><span class="line">#define	LC_SUB_LIBRARY  0x15	/* sub library */</span><br><span class="line">#define	LC_TWOLEVEL_HINTS 0x16	/* two-level namespace lookup hints */</span><br><span class="line">#define	LC_PREBIND_CKSUM  0x17	/* prebind checksum */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * load a dynamically linked shared library that is allowed to be missing</span><br><span class="line"> * (all symbols are weak imported).</span><br><span class="line"> */</span><br><span class="line">#define	LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span><br><span class="line"></span><br><span class="line">#define	LC_SEGMENT_64	0x19	/* 64-bit segment of this file to be</span><br><span class="line">				   mapped */</span><br><span class="line">#define	LC_ROUTINES_64	0x1a	/* 64-bit image routines */</span><br><span class="line">#define LC_UUID		0x1b	/* the uuid */</span><br><span class="line">#define LC_RPATH       (0x1c | LC_REQ_DYLD)    /* runpath additions */</span><br><span class="line">#define LC_CODE_SIGNATURE 0x1d	/* local of code signature */</span><br><span class="line">#define LC_SEGMENT_SPLIT_INFO 0x1e /* local of info to split segments */</span><br><span class="line">#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) /* load and re-export dylib */</span><br><span class="line">#define	LC_LAZY_LOAD_DYLIB 0x20	/* delay load of dylib until first use */</span><br><span class="line">#define	LC_ENCRYPTION_INFO 0x21	/* encrypted segment information */</span><br><span class="line">#define	LC_DYLD_INFO 	0x22	/* compressed dyld information */</span><br><span class="line">#define	LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)	/* compressed dyld information only */</span><br><span class="line">#define	LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD) /* load upward dylib */</span><br><span class="line">#define LC_VERSION_MIN_MACOSX 0x24   /* build for MacOSX min OS version */</span><br><span class="line">#define LC_VERSION_MIN_IPHONEOS 0x25 /* build for iPhoneOS min OS version */</span><br><span class="line">#define LC_FUNCTION_STARTS 0x26 /* compressed table of function start addresses */</span><br><span class="line">#define LC_DYLD_ENVIRONMENT 0x27 /* string for dyld to treat</span><br><span class="line">				    like environment variable */</span><br><span class="line">#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */</span><br><span class="line">#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */</span><br><span class="line">#define LC_SOURCE_VERSION 0x2A /* source version used to build binary */</span><br><span class="line">#define LC_DYLIB_CODE_SIGN_DRS 0x2B /* Code signing DRs copied from linked dylibs */</span><br></pre></td></tr></table></figure><br>常用的有<br>LC_UUID：确定文件的唯一标识，crash reporter 中的 Images 中也会有这个，去检测 dsym 文件和 crash 文件是否匹配，系统库是否找的正确。<br>LC_SEGMENT_64： 将该段(64位)映射到进程地址空间中<br>LC_SEGMENT： 将该段(32位)映射到进程地址空间中<br>LC_SYMTAB：载入符号表地址,可以通过崩溃地址找到崩溃符号（方法）。<br>LC_DYSYMTAB：载入动态符号表地址<br>LC_LOAD_DYLINKER：load_dylinker, 调用dyld（usr/lib/dyld） 动态连接器加载动态库<br>LC_VERSION_MIN_MACOSX/LC_VERSION_MIN_IPHONEOS：确定二进制文件要求的最低操作系统版本<br>LC_SOURCE_VERSION：构建该二进制文件使用的源代码版本<br>LC_MAIN：设置程序主线程的入口地址和栈大小, 在可执行文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The entry_point_command is a replacement for thread_command.</span><br><span class="line"> * It is used for main executables to specify the location (file offset)</span><br><span class="line"> * of main().  If -stack_size was used at link time, the stacksize</span><br><span class="line"> * field will contain the stack size need for the main thread.</span><br><span class="line"> */</span><br><span class="line">struct entry_point_command &#123;</span><br><span class="line">    uint32_t  cmd;	/* LC_MAIN only used in MH_EXECUTE filetypes */</span><br><span class="line">    uint32_t  cmdsize;	/* 24 */</span><br><span class="line">    uint64_t  entryoff;	/* file (__TEXT) offset of main() */</span><br><span class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>LC_ENCRYPTION_INFO_64：获取加密信息<br>LC_LOAD_DYLIB：加载额外的动态库路径，包含三方库<br>LC_FUNCTION_STARTS：定义一个函数起始地址表,使调试器和其他程序易于看到一个地址是否在函数内<br>LC_DATA_IN_CODE：定义在代码段内的非指令的表<br>LC_ID_DYLIB：只在 dylib 中加载，指定了 dylib的ID，版本和兼容版本<br>LC_CODE_SIGNATURE：获取应用签名信息<br>LC_DYLD_INFO_ONLY：加载动态链接库信息（重定向地址、弱引用绑定、懒加载绑定、开放函数等的偏移值等信息）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The dyld_info_command contains the file offsets and sizes of </span><br><span class="line"> * the new compressed form of the information dyld needs to </span><br><span class="line"> * load the image.  This information is used by dyld on Mac OS X</span><br><span class="line"> * 10.6 and later.  All information pointed to by this command</span><br><span class="line"> * is encoded using byte streams, so no endian swapping is needed</span><br><span class="line"> * to interpret it. </span><br><span class="line"> */</span><br><span class="line">struct dyld_info_command &#123;</span><br><span class="line">   uint32_t   cmd;		/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span><br><span class="line">   uint32_t   cmdsize;		/* sizeof(struct dyld_info_command) */</span><br><span class="line"></span><br><span class="line">    uint32_t   rebase_off;	/* file offset to rebase info  */</span><br><span class="line">    uint32_t   rebase_size;	/* size of rebase info   */</span><br><span class="line">   </span><br><span class="line">    uint32_t   bind_off;	/* file offset to binding info   */</span><br><span class="line">    uint32_t   bind_size;	/* size of binding info  */</span><br><span class="line">    </span><br><span class="line">    uint32_t   weak_bind_off;	/* file offset to weak binding info   */</span><br><span class="line">    uint32_t   weak_bind_size;  /* size of weak binding info  */</span><br><span class="line">    </span><br><span class="line">    uint32_t   lazy_bind_off;	/* file offset to lazy binding info */</span><br><span class="line">    uint32_t   lazy_bind_size;  /* size of lazy binding infs */</span><br><span class="line">    </span><br><span class="line">    uint32_t   export_off;	/* file offset to lazy binding info */</span><br><span class="line">    uint32_t   export_size;	/* size of lazy binding infs */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="/2019/02/24/macho-analysis/dyld-info.png" title="&nbsp;"></p>
<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>这个区域提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小。这个区域完整的描述克可执行文件中的全部内容。</p>
<blockquote>
<p>存放数据：代码、字符常量、类、方法等<br>可以拥有多个segment，每个segment可以有零到多个section。每个段都有一段虚拟地址映射到进程的地址空间</p>
</blockquote>
<p>segment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The segment load command indicates that a part of this file is to be</span><br><span class="line"> * mapped into the task&apos;s address space.  The size of this segment in memory,</span><br><span class="line"> * vmsize, maybe equal to or larger than the amount to map from this file,</span><br><span class="line"> * filesize.  The file is mapped starting at fileoff to the beginning of</span><br><span class="line"> * the segment in memory, vmaddr.  The rest of the memory of the segment,</span><br><span class="line"> * if any, is allocated zero fill on demand.  The segment&apos;s maximum virtual</span><br><span class="line"> * memory protection and initial virtual memory protection are specified</span><br><span class="line"> * by the maxprot and initprot fields.  If the segment has sections then the</span><br><span class="line"> * section structures directly follow the segment command and their size is</span><br><span class="line"> * reflected in cmdsize.</span><br><span class="line"> */</span><br><span class="line">struct segment_command &#123; /* for 32-bit architectures */</span><br><span class="line">	uint32_t	cmd;		/* LC_SEGMENT */</span><br><span class="line">	uint32_t	cmdsize;	/* includes sizeof section structs */</span><br><span class="line">	char		segname[16];	/* segment name */</span><br><span class="line">	uint32_t	vmaddr;		/* memory address of this segment */</span><br><span class="line">	uint32_t	vmsize;		/* memory size of this segment */</span><br><span class="line">	uint32_t	fileoff;	/* file offset of this segment */</span><br><span class="line">	uint32_t	filesize;	/* amount to map from the file */</span><br><span class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</span><br><span class="line">	vm_prot_t	initprot;	/* initial VM protection */</span><br><span class="line">	uint32_t	nsects;		/* number of sections in segment */</span><br><span class="line">	uint32_t	flags;		/* flags */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The 64-bit segment load command indicates that a part of this file is to be</span><br><span class="line"> * mapped into a 64-bit task&apos;s address space.  If the 64-bit segment has</span><br><span class="line"> * sections then section_64 structures directly follow the 64-bit segment</span><br><span class="line"> * command and their size is reflected in cmdsize.</span><br><span class="line"> */</span><br><span class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</span><br><span class="line">	uint32_t	cmd;		/* LC_SEGMENT_64 */</span><br><span class="line">	uint32_t	cmdsize;	/* includes sizeof section_64 structs */</span><br><span class="line">	char		segname[16];	/* segment name */</span><br><span class="line">	uint64_t	vmaddr;		/* memory address of this segment */ 段的虚拟内存地址</span><br><span class="line">	uint64_t	vmsize;		/* memory size of this segment */ 为这个段分配的虚拟内存大小</span><br><span class="line">	uint64_t	fileoff;	/* file offset of this segment */ 段在文件中起始地址</span><br><span class="line">	uint64_t	filesize;	/* amount to map from the file */ 段大小</span><br><span class="line">	vm_prot_t	maxprot;	/* maximum VM protection */</span><br><span class="line">	vm_prot_t	initprot;	/* initial VM protection */</span><br><span class="line">	uint32_t	nsects;		/* number of sections in segment */ section个数</span><br><span class="line">	uint32_t	flags;		/* flags */ 标志位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个段，将文件中相对应的内容加载到内存中：从偏移量为fileoff处加载filesize字节到虚拟内存地址vmaddr处的vmsize字节。每一个段的页面都根据initprot进行初始化，initprot指定了如何通过读／写／执行位初始化页面保护级别。段的保护设置可以动态改变，但是不能超过maxprot中指定的值（iOS中，+x 和+w 是互斥的）。</p>
<p>section<br>section分为两种</p>
<blockquote>
<p><strong>TEXT 代码段
</strong>DATA 数据段</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * A segment is made up of zero or more sections. </span><br><span class="line"> */</span><br><span class="line">struct section &#123; /* for 32-bit architectures */</span><br><span class="line">	char		sectname[16];	/* name of this section */</span><br><span class="line">	char		segname[16];	/* segment this section goes in */</span><br><span class="line">	uint32_t	addr;		/* memory address of this section */</span><br><span class="line">	uint32_t	size;		/* size in bytes of this section */</span><br><span class="line">	uint32_t	offset;		/* file offset of this section */</span><br><span class="line">	uint32_t	align;		/* section alignment (power of 2) */</span><br><span class="line">	uint32_t	reloff;		/* file offset of relocation entries */</span><br><span class="line">	uint32_t	nreloc;		/* number of relocation entries */</span><br><span class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</span><br><span class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</span><br><span class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">	char		sectname[16];	/* name of this section */</span><br><span class="line">	char		segname[16];	/* segment this section goes in */</span><br><span class="line">	uint64_t	addr;		/* memory address of this section */</span><br><span class="line">	uint64_t	size;		/* size in bytes of this section */</span><br><span class="line">	uint32_t	offset;		/* file offset of this section */</span><br><span class="line">	uint32_t	align;		/* section alignment (power of 2) */</span><br><span class="line">	uint32_t	reloff;		/* file offset of relocation entries */</span><br><span class="line">	uint32_t	nreloc;		/* number of relocation entries */</span><br><span class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</span><br><span class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</span><br><span class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</span><br><span class="line">	uint32_t	reserved3;	/* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常见section作用<br><img src="/2019/02/24/macho-analysis/section_use.png" title="&nbsp;"></p>
<ul>
<li>每个 section 的起始位置 + 大小就是下个 section 的启始位置</li>
<li>cstring 包含了所有OC的硬编码字符串，nslog 中的字符串也在cstring中，但是不包含含中文的字符串，这些字符串显示的存储在数据段中。不过同样的字符只会存储一次。</li>
<li>ustring 中包含了带中文的硬编码字符串，其他同cstring。</li>
<li><code>__stubs</code>会到 <code>__DATA</code> 段的<code>__la_symbol_ptr</code>中找到函数的入口地址。</li>
</ul>
<h4 id="Loader-Info-（链接信息）"><a href="#Loader-Info-（链接信息）" class="headerlink" title="Loader Info （链接信息）"></a>Loader Info （链接信息）</h4><p>一个完整的用户级 MachO 文件的末端是一系列链接信息。其中包含了动态加载器用来链接可执行文件或者依赖所需使用的符号表、字符串表、dynamic loader info（地址修正，bind）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章中提到了如何自建一个 Crash 平台，其中通过对系统库 (MachO) 的结构解析来寻找崩溃符号。这篇文章就具体讲讲 MachO 文件的结构分析。</p>
<p>iOS中，我们平时看见的 MachO 文件你肯定不陌生，包括静态库(.a)、dSym (yourAppName.dSym)、系统动态库 (/usr/lib/libobjc.A.dylib)、可执行文件等。具体类型下面会讲到。</p>
<p>MachO 二进制文件可以根据前四字节的magic_num来判断是不是 Fat (包含一个或多个架构，有 Fat_Header), 每个架构同样是的 MachO文件。可以这样比喻，相当于对一个或多个文件用文件夹压缩了下。zip 包相当于 Fat，文件是 Thin。每个文件的内部结构式一致的。</p>
<h4 id="Fat"><a href="#Fat" class="headerlink" title="Fat"></a>Fat</h4><img src="/2019/02/24/macho-analysis/fat.png" title="&nbsp;">
<p>可以看到 Fat 多了 Fat_Header信息, 信息中包含架构数，每个架构的基本信息。<br>Fat 可以通过lipo -thin 命令分解出 thin。 thin 也可以合并成 Fat。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分解</span><br><span class="line">lipo BICrashAnalyzeDemo -thin arm64 -output crashAnalyzeDemoARM64</span><br><span class="line">lipo BICrashAnalyzeDemo -thin armv7 -output crashAnalyzeDemoARMV7</span><br><span class="line">//合并</span><br><span class="line">lipo crashAnalyzeDemoARM64 crashAnalyzeDemoARMV7 -create -output BICrashAnalyzeDemo</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何自建 Crash 平台]]></title>
    <link href="http://yoursite.com/2019/02/20/iOS-crash-report/"/>
    <id>http://yoursite.com/2019/02/20/iOS-crash-report/</id>
    <published>2019-02-20T14:54:15.000Z</published>
    <updated>2019-05-22T03:06:48.000Z</updated>
    <content type="html"><![CDATA[<p>【译】<a href="https://www.apteligent.com/technical-resource/symbolicating-an-ios-crash-report/?partner_code=GDC_so_symbolicateios" target="_blank" rel="noopener">Symbolicating an iOS Crash Report</a></p>
<p>通常，当您收到来自iTunes连接的崩溃报告或提供移动崩溃收集和报告的第三方服务（如Apteligent）时，该服务将负责为您提供符号化后的崩溃。如果你没有上传符号，你可能会发现自己有一个非符号化的崩溃，没有别的东西可以继续。这样的崩溃文件对于调试可能影响大量用户的问题并不是非常有用。</p>
<p>在这种情况下，您必须通过将回溯堆栈地址解析为符号来对崩溃报告进行符号化，以获取有关崩溃的有用信息。</p>
<p>幸运的是，完全有可能手动符号化崩溃报告。本文将概述您需要的信息，向您展示如何解释崩溃报告，并查看OSX和XCode上可用的一些工具来符号化崩溃。</p>
<p>崩溃报告中只有两个部分与符号化异常跟踪相关。第一个是 Exception Backtrace 部分。这显示了崩溃时应用程序的调用堆栈。此特定崩溃日志片段显示了我们的 ApteligentExampleApp 应用程序内部崩溃的回溯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation 0x000000018708b100 0x186f80000 + 1093888</span><br><span class="line">1   libobjc.A.dylib            0x00000001939441fc 0x19393c000 + 33276</span><br><span class="line">2   CoreFoundation 0x000000018708b040 0x186f80000 + 1093696</span><br><span class="line">3   ApteligentExampleApp 0x000000010003acc4 0x10002c000 + 60612</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>第二部分是崩溃报告底部的 Binary Images 部分，它为您提供了更多有用的信息。 本节列出了崩溃时加载的二进制文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x10002c000 - 0x1000dffff ApteligentExampleApp arm64  &lt;3759a98e880336108b1a799afa3c1adc&gt; /var/mobile/Applications/46FB38F8-0E69-459F-B96A-CEEA21B77D55/ApteligentExampleApp.app/ApteligentExampleApp</span><br></pre></td></tr></table></figure></p>
<p>不幸的是，这个崩溃报告是未符号化的。 我们可以看到我们的应用程序崩溃的点（异常回溯中的第3行），但它缺少有助于开发人员调试问题的函数名称，函数参数和行号等详细信息。 为了将崩溃报告中的各种地址转换为可读的地址，我们需要将这些地址映射到符号。 为此，我们需要调试符号（dSYM文件）和符号化工具以及从崩溃报告本身收集的信息。</p>
<h3 id="收集所需信息"><a href="#收集所需信息" class="headerlink" title="收集所需信息"></a>收集所需信息</h3><p>这是一个需要符号化的示例行。 我们知道这是程序失败的重点，但地址本身并没有告诉我们任何有用的东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 ApteligentExampleApp 0x000000010003acc4  0x10002c000 + 60612</span><br></pre></td></tr></table></figure></p>
<p>异常回溯中的这一行为您提供堆栈地址，应用程序虚拟内存中的二进制加载地址以及偏移量。 最后一个值只是堆栈地址和加载地址之间的差异。<br>更靠近崩溃报告的底部，您将看到 Binary Images 部分。 通常，崩溃的应用程序将位于列表的顶部。 此条目将为您提供加载地址（再次），此崩溃的dSYM UUID以及应用程序崩溃的系统体系结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary Images:</span><br><span class="line">0x10002c000 - 0x1000dffff +ApteligentExampleApp arm64 &lt;3759a98e880336108b1a799afa3c1adc&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们可以收集所有需要的东西来符号化这一行。 使用此数据，您可以符号化特定崩溃中的任何堆栈地址。<br><img src="http://qiniu.xuyanlan.com/crashAnalyze/symbollist.png" alt=""></p>
<h3 id="验证符号文件"><a href="#验证符号文件" class="headerlink" title="验证符号文件"></a>验证符号文件</h3><p>dSYM 文件是一个 ELF 文件，其中包含应用程序的 DWARF 调试信息（以及其他内容）。 如果在XCode中设置了“带有 dSYM 文件的 DWARF ”选项，则编译器会生成 dSYM 文件，并将其存储在您的构建中。<br><img src="http://qiniu.xuyanlan.com/crashAnalyze/dsym.png" alt=""></p>
<p>如果要表示特定的崩溃，则需要找到匹配的 dSYM 文件。 最好使用某种归档机制将每个版本的 dSYM 和应用程序二进制文件存储到应用商店，因为将崩溃的 dSYM UUID 与正确的 dSYM 文件进行匹配非常重要。 如果 UUID 不完全匹配，则符号化结果不可靠。 崩溃报告将告诉您符号化所需的 dSYM。 如果您不确定您的 dSYM 是否与崩溃匹配，您可以使用 dwarfdump 检查 UUID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump -u ApteligentExampleApp.dSYM</span><br><span class="line">UUID: 3759A98E-8803-3610-8B1A-799AFA3C1ADC (arm64) </span><br><span class="line">ApteligentExampleApp.dSYM</span><br></pre></td></tr></table></figure>
<h3 id="获取偏移量"><a href="#获取偏移量" class="headerlink" title="获取偏移量"></a>获取偏移量</h3><p>对于某些工具，您可能需要提供偏移量而不是加载地址。 如果给它一个加载地址（0x10002c000）和一个堆栈地址（0x10003acc4），ATOS 将为你处理偏移计算。 但是，dwarfdump 和 lldb 采用文件地址（0x10000ECC4），因此您需要考虑为这些工具设置偏移量。<br>从 dSYM 获取偏移量的一种方法是使用“otool”，它可以与 OSX 上的 XCode 开发人员工具一起使用。<br>您需要查找 LC_SEGMENT_64（arm64）或 LC_SEGMENT（armv7，armv7s）段和“vmaddr”条目。 对于iOS，对于32位通常为0x4000，对于64位架构通常为0x100000000，但这可能会发生变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -l ApteligentExampleApp.dSYM &gt; ApteligentExampleApp.otool.output</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Load command 3</span><br><span class="line">cmd LC_SEGMENT_64</span><br><span class="line">cmdsize 1032</span><br><span class="line">segname __TEXT</span><br><span class="line">vmaddr 0x0000000100000000</span><br></pre></td></tr></table></figure>
<p>现在我们已经编译好了所有需要的信息，可以开始符号化堆栈了.</p>
<h3 id="符号化崩溃报告"><a href="#符号化崩溃报告" class="headerlink" title="符号化崩溃报告"></a>符号化崩溃报告</h3><h4 id="使用-ATOS-符号化。"><a href="#使用-ATOS-符号化。" class="headerlink" title="使用 ATOS 符号化。"></a>使用 ATOS 符号化。</h4><p>ATOS是Apple的控制台符号工具。 它将数字地址转换为二进制图像中的符号化字符串。</p>
<p>这是用于在OSX上快速获取符号化输出的最简单工具。 现在您已经从崩溃文件中收集了所有信息，您只需要插入地址并构建信息，您就应该获得符号化的行。 ATOS可以一次处理多个地址，因此如果您愿意，可以从堆栈跟踪中输入每个堆栈地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atos -arch &lt;architecture&gt; -o &lt;binary filename&gt; -l &lt;load address&gt; &lt;stack address 1&gt; &lt;stack address 2&gt; ...</span><br><span class="line">对应</span><br><span class="line">atos -arch arm64 -o ApteligentExampleApp.dSYM -l 0x10002c000 0x000000010003acc4</span><br><span class="line">-[ApteligentExampleClass buggyFunction] (in ApteligentExampleApp.dSYM) (ApteligentExampleClass.m:181)</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-lldb-符号化"><a href="#使用-lldb-符号化" class="headerlink" title="使用 lldb 符号化"></a>使用 lldb 符号化</h4><p>lldb 是 OSX 上 XCode 中的默认调试器，可用于表示崩溃中的行。 lldb 再次包含在 OSX 的XCode 中，还有适用于 Linux，FreeBSD 和 Windows 的端口。 您可以从 <a href="http://lldb.llvm.org/download.html" target="_blank" rel="noopener">llvm 项目站点</a> 获取它。</p>
<p>如果您想了解有关lldb可以执行的操作的更多信息，<a href="http://lldb.llvm.org/symbolication.html" target="_blank" rel="noopener">可以点击此处阅读</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) target create --arch arm64 ApteligentExampleApp.dSYM</span><br><span class="line">Current executable set to ApteligentExampleApp.dSYM&apos; (arm64).</span><br><span class="line">(lldb) image lookup --address 0x10000ECC4</span><br><span class="line">Address: ApteligentExampleApp.dSYM[0x000000010000ecc4] (ApteligentExampleApp.dSYM.__TEXT.__text + 29916)</span><br><span class="line">Summary: ApteligentExampleApp.dSYM`-[ApteligentExampleClass buggyFunction] + 68 at ApteligentExampleClass.m:181</span><br></pre></td></tr></table></figure>
<h4 id="使用-Dwarfdump-符号化"><a href="#使用-Dwarfdump-符号化" class="headerlink" title="使用 Dwarfdump 符号化"></a>使用 Dwarfdump 符号化</h4><p>Dwarfdump 是一个从 EL F对象转储 DWARF 调试信息的实用程序 - 对于 iOS，这通常是一个dSYM 文件。 Dwarfdump 是一个非常冗长的工具，通常用于调试 DWARF 调试信息生成器（如XCode 中的编译器）或验证符号化工具（如 ATOS）的输出。为了简单地表示崩溃转储，使用此工具是完全矫枉过正的，但有时您可能想要进一步深入了解DWARF调试信息。<br>Dwarfdump 使用文件地址（File Address 0x10000ECC4）来定位匹配的子程序“Debug Information Entry”。此条目具有 DWARF 属性，可为您提供有关子程序的信息。对于 Objective C，此子程序条目通常表示类中的函数，您可以获取行号，文件名以及类/函数名称等信息。<br>Dwarfdump 的一个版本随 XCode 开发人员工具一起提供，但您也可以从 <a href="https://www.prevanders.net/dwarf.html" target="_blank" rel="noopener">libdwarf 项目页面</a> 获取它.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --lookup 0x10000ECC4 --arch arm64 ApteligentExampleApp.dSYM</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">File: ApteligentExampleApp.dSYM (arm64)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Looking up address: 0x000000010000ecc4 in .debug_info... found!</span><br><span class="line"></span><br><span class="line">0x000516d2: Compile Unit: length = 0x00000e9f  version = 0x0002  abbr_offset = 0x00000000  addr_size = 0x08  (next CU at 0x00052575)</span><br><span class="line"></span><br><span class="line">0x000516dd: TAG_compile_unit [99] *</span><br><span class="line">AT_producer( &quot;Apple LLVM version 7.0.2 (clang-700.1.81)&quot; )</span><br><span class="line">AT_language( DW_LANG_ObjC )</span><br><span class="line">AT_name( &quot;/Users/kcrawford/src/apteligent-example-apps/ios/ApteligentExampleApp/ApteligentExampleClass.m&quot; )</span><br><span class="line">AT_stmt_list( 0x00008e5a )</span><br><span class="line">AT_comp_dir( &quot;/Users/kcrawford/src/apteligent-example-apps/ios&quot; )</span><br><span class="line">AT_APPLE_major_runtime_vers( 0x02 )</span><br><span class="line">AT_low_pc( 0x000000010000d704 )</span><br><span class="line">AT_high_pc( 0x000000010000f234 )</span><br><span class="line"></span><br><span class="line">0x00051cbd:     TAG_subprogram [116] *</span><br><span class="line">AT_low_pc( 0x000000010000ec80 )</span><br><span class="line">AT_high_pc( 0x000000010000ecd0 )</span><br><span class="line">AT_frame_base( reg29 )</span><br><span class="line">AT_object_pointer( &#123;0x00051cdb&#125; )</span><br><span class="line">AT_name( &quot;-[ApteligentExampleClass buggyFunction]&quot; )</span><br><span class="line">AT_decl_file( &quot;/Users/kcrawford/src/apteligent-example-apps/ios/ApteligentExampleApp/ApteligentExampleClass.m&quot; )</span><br><span class="line">AT_decl_line( 179 )</span><br><span class="line">AT_prototyped( 0x01 )</span><br><span class="line">Line table dir : &apos;/Users/kcrawford/src/apteligent-example-apps/ios/ApteligentExampleApp&apos;</span><br><span class="line">Line table file: &apos;ApteligentExampleClass.m&apos; line 181, column 1 with start address 0x000000010000ecc4</span><br><span class="line">Looking up address: 0x000000010000ecc4 in .debug_frame... not found.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>注意：Xcode 10.2 之后不能指定架构，否则输出为空信息。如果发现输出为空，使用<br>dwarfdump –lookup 0x10000ECC4  ApteligentExampleApp.dSYM 。然后再从输出中找到你要的架构下的信息。</p>
<h4 id="symbolicatecrash"><a href="#symbolicatecrash" class="headerlink" title="symbolicatecrash"></a>symbolicatecrash</h4><p>到目前为止，我们已经研究了在崩溃中表示特定地址的工具，或者至多是 ATOS 中的一系列地址。 为了简化此过程，Apple 发布了一个带有 XCode 的脚本，可以完整地加速崩溃报告的符号化过程。 如果您有 dSYM，app 二进制文件和崩溃报告，这可能是最简单的符号化方法。 您不必担心任何地址 - 此脚本将解析整个故障转储文件并使用 ATOS 将所有地址解析为符号。</p>
<ul>
<li><p>定位系统中的 “symbolicatecrash”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Applications/Xcode.app</span><br><span class="line">find . -name symbolicatecrash</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不存在则导出 DEVELOPER_DIR 环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝 .app二进制文件、crash 报告、.dSYM 文件到临时文件(ex. ~/tmp)</p>
</li>
<li>执行如下脚本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash -v ApteligentExampleApp.crash ApteligentExampleApp.app.dSYM/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果一切顺利，脚本应该符号化整个崩溃文件并将结果输出到终端窗口。 此脚本不会执行任何您无法使用 ATOS 或其他工具手动执行的操作，但它可以更快地为您提供所需的内容。</p>
<h3 id="开始实现自己的符号化平台"><a href="#开始实现自己的符号化平台" class="headerlink" title="开始实现自己的符号化平台"></a>开始实现自己的符号化平台</h3><h4 id="使用脚本批量处理，使用dwarfdump符号化自己App的-崩溃"><a href="#使用脚本批量处理，使用dwarfdump符号化自己App的-崩溃" class="headerlink" title="使用脚本批量处理，使用dwarfdump符号化自己App的 崩溃"></a>使用脚本批量处理，使用dwarfdump符号化自己App的 崩溃</h4><p><a href="http://qiniu.xuyanlan.com/test.zip" target="_blank" rel="noopener">下载测试脚本</a>后 cd 到 test 目录执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sym.py BICrashAnalyzeDemo.crash  BICrashAnalyzeDemo.app.dSYM</span><br></pre></td></tr></table></figure></p>
<p>如果使用 dwarfdump 或者 lldb 命令，计算出来的File Address 地址为 0x0000000100006734 (stack address - load address + Slide Value（0x0000000100000000))。<br>Slide Value（32位虚拟地址）: 0x00004000<br>Slide Value（64位虚拟地址）: 0x0000000100000000 test中使用这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --lookup 0x0000000100006734  --arch arm64 BICrashAnalyzeDemo.app.dSYM/Contents/Resources/DWARF/BICrashAnalyzeDemo </span><br><span class="line"></span><br><span class="line">--arch arm64可省略</span><br></pre></td></tr></table></figure></p>
<p>cd 到 test 目录执行如下命令，导出foo.crash中可看到符号化的非系统崩溃<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python analysis.py BICrashAnalyzeDemo.crash</span><br></pre></td></tr></table></figure></p>
<h4 id="使用atosl符号化系统的崩溃"><a href="#使用atosl符号化系统的崩溃" class="headerlink" title="使用atosl符号化系统的崩溃"></a>使用atosl符号化系统的崩溃</h4><p>系统崩溃需要找出崩溃设备所对应的系统库文件。<br>参考文章:</p>
<ul>
<li><a href="https://juejin.im/post/5ab7dece6fb9a028ba1f7218" target="_blank" rel="noopener">iOS Crash日志分析必备：符号化系统库方法</a></li>
<li><a href="http://turingh.github.io/2016/05/24/nlist-Mach-O%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">nlist-Mach-O文件重定向信息数据结构分析</a></li>
<li><a href="https://www.jianshu.com/p/54d842db3f69" target="_blank" rel="noopener">趣探 Mach-O：文件格式分析</a></li>
</ul>
<p>但是 dwarfdump 是基于 debug_info和 debug_frame解析，而系统库是没有这些的，可以使用 atosl，不过 facebook  的atosl 有些 bug，可能都安装不了，我自己实现了一个。</p>
<h4 id="实现自己的的-macho-解析工具"><a href="#实现自己的的-macho-解析工具" class="headerlink" title="实现自己的的 macho 解析工具"></a>实现自己的的 macho 解析工具</h4><p><a href="http://qiniu.xuyanlan.com/crashAnalyze/atosl.zip" target="_blank" rel="noopener">demo 地址</a></p>
<p>如下部分代码：是分析 macho 文件的代码，得到解析后的结构。根据 loadadress(crash 中的) -  vmaddress(segment vmaddr)得到 slide，再使用 stackadress - slide 可以得到文件地址，再从解析出来 symbol table string 中找到地址所在的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br></pre></td><td class="code"><pre><span class="line">int parse_load_command(char *data, long *offset, struct load_command *lc, struct thin_macho *tm, uint32_t magic_number)&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    switch (lc-&gt;cmd)&#123;</span><br><span class="line">        case LC_UUID:</span><br><span class="line">        &#123;</span><br><span class="line">            struct uuid_command command = &#123;0&#125;;</span><br><span class="line">            memcpy(&amp;command, data + *offset, sizeof(struct uuid_command));</span><br><span class="line">            int i = 0;</span><br><span class="line">            </span><br><span class="line">            FilePrint( &quot;-LC-UUID :&quot;);</span><br><span class="line">            while(i &lt; 16)&#123;</span><br><span class="line">                tm-&gt;uuid[i] = command.uuid[i];</span><br><span class="line">                FilePrint( &quot;%u&quot;,tm-&gt;uuid[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            FilePrint( &quot;\n&quot;);</span><br><span class="line">            debug(&quot;uuid cmdsize = %u,  lc cmdsize = %u&quot;,command.cmdsize,lc-&gt;cmdsize);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LC_SEGMENT:</span><br><span class="line">        &#123;</span><br><span class="line">            struct segment_command command = &#123;0&#125;;</span><br><span class="line">            memcpy(&amp;command, data + *offset, sizeof(struct segment_command));</span><br><span class="line">            if(strcmp(command.segname, &quot;__DWARF&quot;) == 0)&#123;//暂时不处理app 代码 crash</span><br><span class="line">                debug(&quot; is __DWARF skip &quot;);</span><br><span class="line">//                *offset += lc-&gt;cmdsize;</span><br><span class="line">//                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (strcmp(command.segname, &quot;__TEXT&quot;) == 0) &#123;</span><br><span class="line">                tm-&gt;vmaddr32 = command.vmaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            int sectionOff = sizeof(struct segment_command);</span><br><span class="line">            for (int i = 0; i&lt;command.nsects; i++) &#123;</span><br><span class="line">                struct dwarf_section_t *dwarf_s = &#123;0&#125;;</span><br><span class="line">                dwarf_s = malloc(sizeof(struct dwarf_section_t));</span><br><span class="line">                if (dwarf_s == NULL)&#123;</span><br><span class="line">                    printf( &quot;Can not malloc dwarf_s&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                memset(dwarf_s, 0, sizeof(struct dwarf_section_t));</span><br><span class="line">                memcpy(&amp;dwarf_s-&gt;mach_section, data + *offset + sectionOff, sizeof(dwarf_s-&gt;mach_section));</span><br><span class="line">                sectionOff += sizeof(dwarf_s-&gt;mach_section);</span><br><span class="line">               </span><br><span class="line">                struct dwarf_section_t *dwarf_sec = tm-&gt;dwarf_section;</span><br><span class="line">                if(!dwarf_sec) &#123;</span><br><span class="line">                    tm-&gt;dwarf_section = dwarf_s;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    while (dwarf_sec) &#123;</span><br><span class="line">                        if(dwarf_sec-&gt;next == NULL) &#123;</span><br><span class="line">                            dwarf_sec-&gt;next = dwarf_s;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            dwarf_sec = dwarf_sec-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tm-&gt;section_count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LC_SEGMENT_64:</span><br><span class="line">        &#123;</span><br><span class="line">            struct segment_command_64 command = &#123;0&#125;;</span><br><span class="line">            memcpy(&amp;command, data + *offset, sizeof(struct segment_command_64));</span><br><span class="line">            if(strcmp(command.segname, &quot;__DWARF&quot;) == 0)&#123;//暂时不处理app 代码 crash</span><br><span class="line">                debug(&quot; is __DWARF skip &quot;);</span><br><span class="line">//                *offset += lc-&gt;cmdsize;</span><br><span class="line">//                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (strcmp(command.segname, &quot;__TEXT&quot;) == 0) &#123;</span><br><span class="line">                tm-&gt;vmaddr64 = command.vmaddr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            int sectionOff = sizeof(struct segment_command_64);</span><br><span class="line">            for (int i = 0; i&lt;command.nsects; i++) &#123;</span><br><span class="line">                struct dwarf_section_64_t *dwarf_s = &#123;0&#125;;</span><br><span class="line">                dwarf_s = malloc(sizeof(struct dwarf_section_64_t));</span><br><span class="line">                if(dwarf_s == NULL) &#123;</span><br><span class="line">                    printf(&quot;no memory malloc dwarf_s \n&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                memset(dwarf_s, 0, sizeof(struct dwarf_section_64_t));</span><br><span class="line">                memcpy(&amp;dwarf_s-&gt;mach_section, data + *offset + sectionOff, sizeof(dwarf_s-&gt;mach_section));</span><br><span class="line">                sectionOff += sizeof(dwarf_s-&gt;mach_section);</span><br><span class="line">                struct dwarf_section_64_t *dwarf_sec = tm-&gt;dwarf_section_64;</span><br><span class="line">                if(!dwarf_sec) &#123;</span><br><span class="line">                    tm-&gt;dwarf_section_64 = dwarf_s;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    while (dwarf_sec) &#123;</span><br><span class="line">                        if(dwarf_sec-&gt;next == NULL) &#123;</span><br><span class="line">                            dwarf_sec-&gt;next = dwarf_s;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            dwarf_sec = dwarf_sec-&gt;next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tm-&gt;section_count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LC_SYMTAB:</span><br><span class="line">        &#123;</span><br><span class="line">            struct symtab_command command = &#123;0&#125;;</span><br><span class="line">            memcpy(&amp;command, data + *offset, sizeof(struct symtab_command));</span><br><span class="line">            tm-&gt;nsyms = command.nsyms;</span><br><span class="line">            tm-&gt;strsize = command.strsize;</span><br><span class="line">            tm-&gt;stroff = command.stroff;</span><br><span class="line">            tm-&gt;strings = data + command.stroff;</span><br><span class="line">            if(magic_number == MH_MAGIC_64)&#123;</span><br><span class="line">                tm-&gt;symbollist = malloc(command.nsyms * sizeof(struct symbol_t));</span><br><span class="line">                if(tm-&gt;symbollist == NULL) &#123;</span><br><span class="line">                    printf( &quot;no memory symbollist \n&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                memset(tm-&gt;symbollist, &apos;\0&apos;, command.nsyms * sizeof(struct symbol_t));</span><br><span class="line">                struct symbol_t *current = tm-&gt;symbollist;</span><br><span class="line">                int i = 0;</span><br><span class="line">                uint32_t listOffset = 0;</span><br><span class="line">                for (; i &lt; command.nsyms; i++) &#123;</span><br><span class="line">                    memcpy(&amp;current-&gt;sym.sym64, data + command.symoff + listOffset, sizeof(struct nlist_64));</span><br><span class="line">                    uint32_t n_strx = current-&gt;sym.sym64.n_un.n_strx;</span><br><span class="line">                    if(n_strx &lt; 0)&#123;</span><br><span class="line">                        current-&gt;name = &quot;&quot;;</span><br><span class="line">                    &#125;else if(n_strx &gt; command.strsize)&#123;</span><br><span class="line">                        current-&gt;name = &quot;bad string index&quot;;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        current-&gt;name = tm-&gt;strings + n_strx;</span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                    listOffset += sizeof(struct nlist_64);</span><br><span class="line">                    current++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                uint32_t listOffset = 0;</span><br><span class="line">                tm-&gt;symbollist = malloc(command.nsyms * sizeof(struct symbol_t));</span><br><span class="line">                if(tm-&gt;symbollist == NULL)&#123;</span><br><span class="line">                    printf( &quot;no memory symbollist \n&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                memset(tm-&gt;symbollist, &apos;\0&apos;, command.nsyms * sizeof(struct symbol_t));</span><br><span class="line">                struct symbol_t *current = tm-&gt;symbollist;</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (i = 0; i &lt; command.nsyms; i++) &#123;</span><br><span class="line">                    memcpy(&amp;current-&gt;sym.sym32, data + command.symoff + listOffset, sizeof(struct nlist));</span><br><span class="line">                    if(current-&gt;sym.sym32.n_un.n_strx &lt; 0)&#123;</span><br><span class="line">                        current-&gt;name = &quot;&quot;;</span><br><span class="line">                    &#125;else if(current-&gt;sym.sym32.n_un.n_strx &gt; command.strsize)&#123;</span><br><span class="line">                        current-&gt;name = &quot;bad string index&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        current-&gt;name = tm-&gt;strings + current-&gt;sym.sym32.n_un.n_strx;</span><br><span class="line">                    &#125;</span><br><span class="line">                    listOffset += sizeof(struct nlist);</span><br><span class="line">                    current++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result = 0;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    *offset += lc-&gt;cmdsize;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">//parse</span><br><span class="line">int parse_macho(struct thin_macho *tm) &#123;</span><br><span class="line">    char *macho_str = tm-&gt;data;</span><br><span class="line">    int num_load_cmds = 0;</span><br><span class="line">    long offset = 0;</span><br><span class="line">    size_t header_size = 0;</span><br><span class="line">    uint32_t magic_number = 0;</span><br><span class="line">    memcpy(&amp;magic_number, macho_str, sizeof(uint32_t));</span><br><span class="line">    switch (magic_number) &#123;</span><br><span class="line">        case MH_MAGIC:</span><br><span class="line">        &#123;</span><br><span class="line">            struct mach_header mh = &#123;0&#125;;</span><br><span class="line">            header_size = sizeof(struct mach_header);</span><br><span class="line">            memcpy(&amp;mh, macho_str + offset, header_size);</span><br><span class="line">            num_load_cmds = mh.ncmds;</span><br><span class="line">            tm-&gt;cputype = mh.cputype;</span><br><span class="line">            tm-&gt;cpusubtype = mh.cpusubtype;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MH_MAGIC_64:</span><br><span class="line">        &#123;</span><br><span class="line">            struct mach_header_64 mh64 = &#123;0&#125;;</span><br><span class="line">            header_size = sizeof(struct mach_header_64);</span><br><span class="line">            memcpy(&amp;mh64, macho_str + offset, header_size);</span><br><span class="line">            num_load_cmds = mh64.ncmds;</span><br><span class="line">            tm-&gt;cputype = mh64.cputype;</span><br><span class="line">            if(tm-&gt;cputype == CPU_TYPE_ARM64 &amp;&amp; tm-&gt;cpusubtype == CPU_SUBTYPE_ARM64_ALL) &#123;</span><br><span class="line">                tm-&gt;is_64 = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            tm-&gt;cpusubtype = mh64.cpusubtype;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MH_CIGAM:</span><br><span class="line">            printf(&quot;TODO: MH_CIGAM\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case MH_CIGAM_64:</span><br><span class="line">            printf(&quot;TODO: MH_CIGAM_64\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case FAT_MAGIC:</span><br><span class="line">        case FAT_CIGAM:</span><br><span class="line">            printf( &quot;fat in fat?\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            debug(&quot;not found magic_num = %u&quot;,magic_number);</span><br><span class="line">            printf( &quot;magic_number invalid.&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += header_size;</span><br><span class="line">    struct load_command lc = &#123;0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    </span><br><span class="line">    while (i &lt; num_load_cmds) &#123;</span><br><span class="line">        memcpy(&amp;lc, macho_str + offset, sizeof(struct load_command));</span><br><span class="line">        int lc_result = parse_load_command(macho_str, &amp;offset, &amp;lc, tm, magic_number);</span><br><span class="line">        if(lc_result == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">//    sortSymbolAddr(tm);print part</span><br><span class="line">    InsertSort(tm-&gt;symbollist,tm-&gt;nsyms, tm-&gt;is_64);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int parse_thin(FILE *fp,uint32_t magic_num, struct target_file *tf) &#123;</span><br><span class="line">    tf-&gt;numofarchs = 1;</span><br><span class="line">    tf-&gt;thin_machos = malloc(1 * sizeof(struct thin_macho*));</span><br><span class="line">    if (tf-&gt;thin_machos == NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(tf-&gt;thin_machos, &apos;\0&apos;, 1 * sizeof(struct thin_macho*));</span><br><span class="line">    fseek(fp, 0L, SEEK_END);</span><br><span class="line">    long int size = ftell(fp);</span><br><span class="line">    fseek(fp, 0L, SEEK_SET);</span><br><span class="line">    tf-&gt;thin_machos[0] = malloc(sizeof(struct thin_macho));</span><br><span class="line">    if(tf-&gt;thin_machos[0] == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(tf-&gt;thin_machos[0], &apos;\0&apos;, sizeof(struct thin_macho));</span><br><span class="line">    tf-&gt;thin_machos[0]-&gt;data = malloc(size);</span><br><span class="line">    if(tf-&gt;thin_machos[0]-&gt;data == NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(tf-&gt;thin_machos[0]-&gt;data, &apos;\0&apos;, size);</span><br><span class="line">    long numofbytes = 0;</span><br><span class="line">    numofbytes = fread(tf-&gt;thin_machos[0]-&gt;data, sizeof(char), size, fp);</span><br><span class="line">    assert(numofbytes == size);</span><br><span class="line">    if(numofbytes == size)&#123;</span><br><span class="line">        int result = parse_macho(tf-&gt;thin_machos[0]);</span><br><span class="line">        if(result == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int parse_fat(FILE *fp,uint32_t magic_num, struct target_file *tf) &#123;</span><br><span class="line">    long rc = 0;</span><br><span class="line">    struct fat_header fh = &#123;0&#125;;</span><br><span class="line">    uint32_t nfat_arch = 0;</span><br><span class="line">    debug(&quot;sizeof(struct fat_header) is = %lu&quot;,sizeof(struct fat_header));</span><br><span class="line">    if((rc = fread(&amp;fh, sizeof(struct fat_header), 1, fp)) != 0) &#123;</span><br><span class="line">        if(magic_num == FAT_CIGAM)&#123;</span><br><span class="line">            FilePrint(&quot;-magic_num :  FAT_CIGAM\n&quot;);</span><br><span class="line">            uint32_endian_convert(&amp;fh.nfat_arch);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            FilePrint(&quot;-magic_num :  FAT_MAGIC\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        nfat_arch = fh.nfat_arch;</span><br><span class="line">        FilePrint(&quot;-arch count : %u \n&quot;,nfat_arch);</span><br><span class="line">    &#125;</span><br><span class="line">    tf-&gt;numofarchs = nfat_arch;</span><br><span class="line">    tf-&gt;thin_machos = malloc(sizeof(struct thin_macho *));</span><br><span class="line">    if(tf-&gt;thin_machos == NULL) &#123;</span><br><span class="line">        printf( &quot;parse_fat Can not malloc thin_machos*&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(tf-&gt;thin_machos, &apos;\0&apos;, nfat_arch * sizeof(struct thin_macho *));</span><br><span class="line">    uint32_t i = 0;</span><br><span class="line">    struct fat_arch fa = &#123;0&#125;;</span><br><span class="line">    while (i &lt; nfat_arch) &#123;</span><br><span class="line">        tf-&gt;thin_machos[i] = malloc(sizeof(struct thin_macho));</span><br><span class="line">        if(tf-&gt;thin_machos[i] == NULL) &#123;</span><br><span class="line">            printf( &quot;parse_fat Can not malloc thin_machos[%d]&quot;,i);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(tf-&gt;thin_machos[i], &apos;\0&apos;, sizeof(struct thin_macho));</span><br><span class="line">        debug(&quot;sizeof(struct fat_arch) is = %lu  \n sizeof(char) = %lu&quot;,sizeof(struct fat_arch),sizeof(char));</span><br><span class="line">        if((rc = fread(&amp;fa, sizeof(struct fat_arch), 1, fp)) == 1) &#123;</span><br><span class="line">            if(magic_num == FAT_CIGAM)&#123;</span><br><span class="line">                integer_t_endian_convert(&amp;fa.cputype);</span><br><span class="line">                integer_t_endian_convert(&amp;fa.cpusubtype);</span><br><span class="line">                uint32_endian_convert(&amp;fa.offset);</span><br><span class="line">                uint32_endian_convert(&amp;fa.size);</span><br><span class="line">                uint32_endian_convert(&amp;fa.align);</span><br><span class="line">            &#125;</span><br><span class="line">            tf-&gt;thin_machos[i]-&gt;data = malloc(fa.size);</span><br><span class="line">            if (tf-&gt;thin_machos[i]-&gt;data == NULL)&#123;</span><br><span class="line">                printf( &quot;Can not malloc data&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            memset(tf-&gt;thin_machos[i]-&gt;data, &apos;\0&apos;, fa.size);</span><br><span class="line">            long cur_pos = ftell(fp);</span><br><span class="line">            fseek(fp, fa.offset, SEEK_SET);</span><br><span class="line">            long numofbytes = 0;</span><br><span class="line">            numofbytes = fread(tf-&gt;thin_machos[i]-&gt;data, sizeof(char), fa.size, fp);</span><br><span class="line">            if(numofbytes != fa.size) &#123;</span><br><span class="line">                printf( &quot;parse_fat read macho data error. i = %u \n&quot;,i);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            fseek(fp, cur_pos, SEEK_SET);//获取完 data。回到原处</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            printf( &quot;read fat arch error\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int result = parse_macho(tf-&gt;thin_machos[i]);</span><br><span class="line">        if(result == -1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct target_file *parse_file(const char *filename)&#123;</span><br><span class="line">    FILE *fp = fopen(filename, &quot;rb&quot;);</span><br><span class="line">    if (fp == NULL)&#123;</span><br><span class="line">        printf( &quot;Can not open file %s for read.\n&quot;, filename);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    struct target_file *tf = malloc(sizeof(struct target_file));</span><br><span class="line">    if (tf == NULL)&#123;</span><br><span class="line">        printf( &quot;Can not malloc target_file&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //申请内存</span><br><span class="line">    memset(tf, &apos;\0&apos;, sizeof(struct target_file));</span><br><span class="line">    long rc = 0;</span><br><span class="line">    uint32_t magic_num = 0;</span><br><span class="line">    int parse_result = -1;</span><br><span class="line">    //前四字节为魔数</span><br><span class="line">    if((rc = fread(&amp;magic_num, sizeof(uint32_t), 1, fp)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fseek(fp, 0L, SEEK_SET);</span><br><span class="line">        switch (magic_num) &#123;</span><br><span class="line">            case MH_MAGIC:</span><br><span class="line">                debug(&quot;MH_MAGIC&quot;);</span><br><span class="line">                parse_result = parse_thin(fp,MH_MAGIC,tf);</span><br><span class="line">                break;</span><br><span class="line">            case MH_MAGIC_64:</span><br><span class="line">                debug(&quot;MH_MAGIC_64&quot;);</span><br><span class="line">                parse_result = parse_thin(fp,MH_MAGIC_64,tf);</span><br><span class="line">                break;</span><br><span class="line">            case MH_CIGAM_64://macho 和 平台编码不一致</span><br><span class="line">                debug(&quot;MH_CIGAM_64&quot;);</span><br><span class="line">                printf(&quot;MH_CIGAM_64: %x\n&quot;, MH_CIGAM_64);</span><br><span class="line">                break;</span><br><span class="line">            case FAT_MAGIC://大端序</span><br><span class="line">                debug(&quot;FAT_MAGIC&quot;);</span><br><span class="line">                parse_result = parse_fat(fp,FAT_MAGIC,tf);</span><br><span class="line">                break;</span><br><span class="line">            case FAT_CIGAM:</span><br><span class="line">                debug(&quot;FAT_CIGAM&quot;);</span><br><span class="line">                parse_result = parse_fat(fp,FAT_CIGAM,tf);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                debug(&quot;not found magic_num = %u&quot;,magic_num);</span><br><span class="line">                printf( &quot;magic_number invalid.&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    if(parse_result == -1)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return tf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int symbolicate(const char* arch, const char *executable, const char *loadAddr, char *addresses[])&#123;</span><br><span class="line">    char *filename = strrchr(executable, &apos;/&apos;);</span><br><span class="line">    if(filename == NULL)&#123;</span><br><span class="line">        filename = (char *)executable;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        filename = filename + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //开始读取二进制文件</span><br><span class="line">    debug(&quot;about to analysis file.&quot;);</span><br><span class="line">    struct target_file *tf = parse_file(executable);</span><br><span class="line">    int result = findAddressInMacho(tf, arch,loadAddr, addresses);</span><br><span class="line">    free_target_file(tf);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请自行替换文件地址再运行。可以从 result.txt 中看到解析后的结构。可以看到和 machoview 解析出来的结构一致。</p>
<p>接下来：<br>1：对 symbol table string 列表的 value 排序，symbol table string中包含方法名。<br>2：使用上面提到的文件地址去排好序的 value 中查找，查找到小于 value 的 index，则崩溃的方法名存在于 index-1 项。<br>可以看到，找到的系统崩溃和 symbolicatecrash 符号化出来的 output.crash 中一致。<br><img src="http://qiniu.xuyanlan.com/crashAnalyze/find.png" alt=""></p>
<h4 id="后续：自建crash-分析平台"><a href="#后续：自建crash-分析平台" class="headerlink" title="后续：自建crash 分析平台"></a>后续：自建crash 分析平台</h4><p>自建 crash 分析平台的路还有很长，目前我也刚走到第三步。分为：<br>OS 平台：Ubuntu<br>1：安装 Ubuntu 虚拟机18.04LTS版本，只有这个版本才支持 dwarfdump。apt-get 安装 llvm-dwarfdump<br>使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dwarfdump -lookup 0x0000000100006734   BICrashAnalyzeDemo.app.dSYM/Contents/Resources/DWARF/BICrashAnalyzeDemo</span><br></pre></td></tr></table></figure><br>结果<br><img src="http://qiniu.xuyanlan.com/crashAnalyze/ubantu.png" alt=""><br>可以看到和 macox 上 dwarfdump 结果差不多，上面的脚本改改能继续用来符号化 AppName 的崩溃。</p>
<p>2：安装自己实现的 atosl，符号化系统崩溃。<br>3：脚本批量符号化 crash 文件。<br>4：crash 分类<br>5：crash 额外信息添加</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>【译】<a href="https://www.apteligent.com/technical-resource/symbolicating-an-ios-crash-report/?partner_code=GDC_so_symbolicateios" target="_blank" rel="noopener">Symbolicating an iOS Crash Report</a></p>
<p>通常，当您收到来自iTunes连接的崩溃报告或提供移动崩溃收集和报告的第三方服务（如Apteligent）时，该服务将负责为您提供符号化后的崩溃。如果你没有上传符号，你可能会发现自己有一个非符号化的崩溃，没有别的东西可以继续。这样的崩溃文件对于调试可能影响大量用户的问题并不是非常有用。</p>
<p>在这种情况下，您必须通过将回溯堆栈地址解析为符号来对崩溃报告进行符号化，以获取有关崩溃的有用信息。</p>
<p>幸运的是，完全有可能手动符号化崩溃报告。本文将概述您需要的信息，向您展示如何解释崩溃报告，并查看OSX和XCode上可用的一些工具来符号化崩溃。</p>
<p>崩溃报告中只有两个部分与符号化异常跟踪相关。第一个是 Exception Backtrace 部分。这显示了崩溃时应用程序的调用堆栈。此特定崩溃日志片段显示了我们的 ApteligentExampleApp 应用程序内部崩溃的回溯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation 0x000000018708b100 0x186f80000 + 1093888</span><br><span class="line">1   libobjc.A.dylib            0x00000001939441fc 0x19393c000 + 33276</span><br><span class="line">2   CoreFoundation 0x000000018708b040 0x186f80000 + 1093696</span><br><span class="line">3   ApteligentExampleApp 0x000000010003acc4 0x10002c000 + 60612</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="技术调研" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[block 探索]]></title>
    <link href="http://yoursite.com/2019/02/11/block/"/>
    <id>http://yoursite.com/2019/02/11/block/</id>
    <published>2019-02-10T21:31:14.000Z</published>
    <updated>2019-07-06T08:40:20.770Z</updated>
    <content type="html"><![CDATA[<h3 id="block-转-c-源码"><a href="#block-转-c-源码" class="headerlink" title="block 转 c++ 源码"></a>block 转 c++ 源码</h3><p>如下代码 .h .m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//TestClang.h</span><br><span class="line">@interface TestClang : NSObject</span><br><span class="line">+ (void)testBlcok;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//TestClang.m</span><br><span class="line">#import &quot;TestClang.h&quot;</span><br><span class="line">static int numGlobel = 29;</span><br><span class="line">@implementation TestClang</span><br><span class="line">+ (void)testBlcok &#123;</span><br><span class="line">    //没有截获局部变量 __NSGlobalBlock__</span><br><span class="line">    void(^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">    NSLog(@&quot; block1 = %@&quot;, block1);</span><br><span class="line">    block1();</span><br><span class="line">    static int numStatic = 12;</span><br><span class="line">    int num = 10;</span><br><span class="line">    __block int numBlock = 19;</span><br><span class="line">    __block int numBlock2 = 30;</span><br><span class="line">    __block int numBlockTest = 30;</span><br><span class="line">        void(^block2)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block === %d, numStatic = %d numGlobel = %d  numBlock=%d numBlock2=%d numBlockTest = %d&quot;, num,numStatic,numGlobel,numBlock,numBlock2,numBlockTest);</span><br><span class="line">            &#125;;</span><br><span class="line">    num = 33;</span><br><span class="line">    numStatic = 121;</span><br><span class="line">    numGlobel = 129;</span><br><span class="line">    numBlock = 22222;</span><br><span class="line">    block2();</span><br><span class="line">    NSLog(@&quot;block2 = %@&quot;, block2);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc TestClang.m<br>不要引用其他头文件，以免导出报Error<br>目录下生成了一个TestClang.cpp文件</p>
</blockquote>
<ul>
<li>testBlock 对应的方法变为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//_C_ 表示为类方法 _I_ 为实例方法</span><br><span class="line">static void _C_TestClang_testBlcok(Class self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    void(*block1)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_0((void *)__TestClang__testBlcok_block_func_0, &amp;__TestClang__testBlcok_block_desc_0_DATA));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_cf514e_mi_1, block1);</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    static int numStatic = 12;</span><br><span class="line">    int num = 10;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlock_0 numBlock = &#123;(void*)0,(__Block_byref_numBlock_0 *)&amp;numBlock, 0, sizeof(__Block_byref_numBlock_0), 19&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlock2_1 numBlock2 = &#123;(void*)0,(__Block_byref_numBlock2_1 *)&amp;numBlock2, 0, sizeof(__Block_byref_numBlock2_1), 30&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlockTest_2 numBlockTest = &#123;(void*)0,(__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 0, sizeof(__Block_byref_numBlockTest_2), 30&#125;;</span><br><span class="line"></span><br><span class="line">        void(*block2)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_1((void *)__TestClang__testBlcok_block_func_1, &amp;__TestClang__testBlcok_block_desc_1_DATA, num, &amp;numStatic, (__Block_byref_numBlock_0 *)&amp;numBlock, (__Block_byref_numBlock2_1 *)&amp;numBlock2, (__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 570425344));</span><br><span class="line">    num = 33;</span><br><span class="line">    numStatic = 121;</span><br><span class="line">    numGlobel = 129;</span><br><span class="line">    (numBlock.__forwarding-&gt;numBlock) = 22222;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_cf514e_mi_3, block2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="block-变量定义"><a href="#block-变量定义" class="headerlink" title="block 变量定义"></a>block 变量定义</h4><p>OC 代码中定义了了block1 和 block2 两个 block 变量，我们看 block1 变量定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void(*block1)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_0((void *)__TestClang__testBlcok_block_func_0, &amp;__TestClang__testBlcok_block_desc_0_DATA));</span><br></pre></td></tr></table></figure></p>
<p>上述定义代码中，可以发现，block1 定义中调用了 <code>__TestClang__testBlcok_block_impl_0</code> 并且将 <code>__TestClang__testBlcok_block_func_0</code> 函数 和 <code>__TestClang__testBlcok_block_desc_0_DATA</code> 地址赋值给了 block1。（你可能注意到了命名规则 <code>__类名__方法名__block__impl_第几个block</code>，desc 和 func 类似）。<br>block1() 的调用简化后就是 block1-&gt;FuncPtr 了。<br>那么我们来看一下 <code>__TestClang__testBlcok_block_impl_0</code> 结构体的内部结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __TestClang__testBlcok_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestClang__testBlcok_block_desc_0* Desc;</span><br><span class="line">  __TestClang__testBlcok_block_impl_0(void *fp, struct __TestClang__testBlcok_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;//用于初始化 __block_impl 结构体的isa成员</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结构体实现了一个同名的构造函数，也就是说将 <code>__TestClang__testBlcok_block_impl_0</code> 结构体的地址赋值给了 block1 变量；<br><code>__TestClang__testBlcok_block_impl_0</code> 的构造函数参数有 （void*）<code>__TestClang__testBlcok_block_func_0</code> 、<code>__TestClang__testBlcok_block_desc_0_DATA</code> flags=0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __TestClang__testBlcok_block_func_0(struct __TestClang__testBlcok_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_61ed5f_mi_0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">static struct __TestClang__testBlcok_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __TestClang__testBlcok_block_desc_0_DATA = &#123; 0, sizeof(struct __TestClang__testBlcok_block_impl_0)&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们可以看到 <code>__TestClang__testBlcok_block_desc_0</code> 中存储着两个参数，reserved 和 Block_size，并且 reserved 赋值为0而 Block_size 则存储着 <code>__TestClang__testBlcok_block_impl_0</code> 的占用空间大小。最终将 <code>__TestClang__testBlcok_block_desc_0</code> 结构体的地址传入 <code>__TestClang__testBlcok_block_impl_0</code> 中赋值给 Desc。<br>然而 block1 只是一个最简单的 block ，没有截获任何变量。运行时打印 block1 会发现 block1 是 <code>__NSGlobalBlock__</code> 类型（原因：只要block没有引用栈或堆上的数据，编译器则会吧 block1 优化为  <code>__NSGlobalBlock__</code> 类型）。<br>Block即为 OC 对象。</p>
<p>下面我们来看下截获了外部值的 block。</p>
<h4 id="截获局部变量、静态变量、全局静态变量、-block-变量的-block"><a href="#截获局部变量、静态变量、全局静态变量、-block-变量的-block" class="headerlink" title="截获局部变量、静态变量、全局静态变量、__block 变量的 block"></a>截获局部变量、静态变量、全局静态变量、__block 变量的 block</h4><p>block2 变量的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        void(*block2)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_1((void *)__TestClang__testBlcok_block_func_1, &amp;__TestClang__testBlcok_block_desc_1_DATA, num, &amp;numStatic, (__Block_byref_numBlock_0 *)&amp;numBlock, (__Block_byref_numBlock2_1 *)&amp;numBlock2, (__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 570425344));</span><br></pre></td></tr></table></figure><br>block2 变量的声明看起来比较复杂，对应 OC 源码分析：</p>
<ul>
<li>可以看到 <code>__TestClang__testBlcok_block_impl_1</code> 中的结构体成员变多了,那就是截获的自动变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __TestClang__testBlcok_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestClang__testBlcok_block_desc_1* Desc;</span><br><span class="line">  int num;</span><br><span class="line">  int *numStatic; //静态局部变量地址截获， 对于全局的静态变量，可以直接使用，不需要截获为结构题成员变量</span><br><span class="line">  __Block_byref_numBlock_0 *numBlock; // by ref 声明了 __block 的局部变量 (命名规则：__Block_byref_变量名_第几个ref）</span><br><span class="line">  __Block_byref_numBlock2_1 *numBlock2; // by ref 声明了 __block 的局部变量</span><br><span class="line">  __Block_byref_numBlockTest_2 *numBlockTest; // by ref 声明了 __block 的局部变量</span><br><span class="line">  __TestClang__testBlcok_block_impl_1(void *fp, struct __TestClang__testBlcok_block_desc_1 *desc, int _num, int *_numStatic, __Block_byref_numBlock_0 *_numBlock, __Block_byref_numBlock2_1 *_numBlock2, __Block_byref_numBlockTest_2 *_numBlockTest, int flags=0) : num(_num), numStatic(_numStatic), numBlock(_numBlock-&gt;__forwarding), numBlock2(_numBlock2-&gt;__forwarding), numBlockTest(_numBlockTest-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来同样看下<strong>TestClang</strong>testBlcok_block_impl_1 构造函数的参数</p>
<ul>
<li><code>__TestClang__testBlcok_block_func_1</code> block2 的 FuncPtr<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __TestClang__testBlcok_block_func_1(struct __TestClang__testBlcok_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_numBlock_0 *numBlock = __cself-&gt;numBlock; // bound by ref</span><br><span class="line">  __Block_byref_numBlock2_1 *numBlock2 = __cself-&gt;numBlock2; // bound by ref</span><br><span class="line">  __Block_byref_numBlockTest_2 *numBlockTest = __cself-&gt;numBlockTest; // bound by ref</span><br><span class="line">  int num = __cself-&gt;num; // bound by copy</span><br><span class="line">  int *numStatic = __cself-&gt;numStatic; // bound by copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_d96c9e_mi_2, num,(*numStatic),numGlobel,(numBlock-&gt;__forwarding-&gt;numBlock),(numBlock2-&gt;__forwarding-&gt;numBlock2),(numBlockTest-&gt;__forwarding-&gt;numBlockTest));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<code>__self</code>相当于C++实例方法中指向实例自身的变量this，或是Objevtive-C 实例方法中指向对象自身的变量self，即<code>__this</code>为指向Block值的变量</li>
<li><p><code>__TestClang__testBlcok_block_desc_1_DATA</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct __TestClang__testBlcok_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestClang__testBlcok_block_impl_1*, struct __TestClang__testBlcok_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __TestClang__testBlcok_block_impl_1*);</span><br><span class="line">&#125; __TestClang__testBlcok_block_desc_1_DATA = &#123; 0, sizeof(struct __TestClang__testBlcok_block_impl_1), __TestClang__testBlcok_block_copy_1, __TestClang__testBlcok_block_dispose_1&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增了<code>__TestClang__testBlcok_block_copy_1</code> 和 <code>__TestClang__testBlcok_block_dispose_1</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void __TestClang__testBlcok_block_copy_1(struct __TestClang__testBlcok_block_impl_1*dst, struct __TestClang__testBlcok_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;numBlock, (void*)src-&gt;numBlock, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;numBlock2, (void*)src-&gt;numBlock2, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;numBlockTest, (void*)src-&gt;numBlockTest, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestClang__testBlcok_block_dispose_1(struct __TestClang__testBlcok_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;numBlock, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;numBlock2, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;numBlockTest, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br></pre></td></tr></table></figure>
<p><code>__TestClang__testBlcok_block_copy_1</code> 函数中所使用的<code>_Block_object_assign</code>函数将对象类型对象复制给 Block 用结构体的成员变量 arc 并持有该对象，调用<code>_Block_object_assign</code>函数相当于retain函数，将对象赋值在对象类型的结构体成员变量中。<br><code>__TestClang__testBlcok_block_dispose_1</code> 函数中使用 <code>_Block_object_dispose</code> 函数释放赋值在 Block 用结构体成员变量 arc 中的对象。调用 <code>_Block_object_dispose</code>函数相当于调用release函数，释放赋值在对象类型结构体中的对象。</p>
</li>
<li><p>带<code>__block</code>的局部变量变为了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//查看__Block_byref的定义</span><br><span class="line"></span><br><span class="line">struct __Block_byref_numBlock_0 &#123;</span><br><span class="line">  void *__isa; //(void*)0</span><br><span class="line">__Block_byref_numBlock_0 *__forwarding; //指向结构体地址</span><br><span class="line"> int __flags; //0</span><br><span class="line"> int __size; //byref 大小</span><br><span class="line"> int numBlock; //byref 截获的值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((__blocks__(byref))) __Block_byref_numBlock_0 numBlock = &#123;(void*)0,(__Block_byref_numBlock_0 *)&amp;numBlock, 0, sizeof(__Block_byref_numBlock_0), 19&#125;;</span><br><span class="line">__attribute__((__blocks__(byref))) __Block_byref_numBlock2_1 numBlock2 = &#123;(void*)0,(__Block_byref_numBlock2_1 *)&amp;numBlock2, 0, sizeof(__Block_byref_numBlock2_1), 30&#125;;</span><br><span class="line">__attribute__((__blocks__(byref))) __Block_byref_numBlockTest_2 numBlockTest = &#123;(void*)0,(__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 0, sizeof(__Block_byref_numBlockTest_2), 30&#125;;</span><br><span class="line">通过上面的拆解，那么改变 __block 修饰的变量的值会变为下面这种形式</span><br><span class="line">(numBlock.__forwarding-&gt;numBlock) = 22222;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="block-底层关系图解"><a href="#block-底层关系图解" class="headerlink" title="block 底层关系图解"></a>block 底层关系图解</h3><p>先拿网络上的图吧，懒得画。<br><img src="/2019/02/11/block/block.jpeg" title="&nbsp;"></p>
<h3 id="block-的三种类型"><a href="#block-的三种类型" class="headerlink" title="block 的三种类型"></a>block 的三种类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）</span><br><span class="line">__NSStackBlock__ （ _NSConcreteStackBlock ）</span><br><span class="line">__NSMallocBlock__ （ _NSConcreteMallocBlock ）</span><br></pre></td></tr></table></figure>
<p>上面提到block1是 <code>__NSGlobalBlock__</code>类型，原因是因为没有截获堆上或栈上的变量。测试如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlcok &#123;</span><br><span class="line">    //没有截获局部变量 __NSGlobalBlock__</span><br><span class="line">    void(^blockA)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;, blockA);</span><br><span class="line">    //原因：只要block literal里没有引用栈或堆上的数据，那么这个block会自动变为__NSGlobalBlock__类型，这是编译器的优化</span><br><span class="line">    // int value = 10; 改为 const int value = 10; 则会为__NSGlobalBlock__ ，因为加上const 的 value存储在常量区</span><br><span class="line">    //截获了局部变量 __NSMallocBlock__</span><br><span class="line">    int value = 10;</span><br><span class="line">        void(^blockB)(void) = ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;just a block === %d&quot;, value);</span><br><span class="line">            &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;, blockB);</span><br><span class="line">    //一般并不会这么使用</span><br><span class="line">    // __NSStackBlock__</span><br><span class="line">    void(^ __weak blockC)() = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block === %d&quot;, value);</span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, blockC);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类型定义：<br><img src="/2019/02/11/block/type.png" title="&nbsp;"></p>
<h3 id="Block在内存中的存储"><a href="#Block在内存中的存储" class="headerlink" title="Block在内存中的存储"></a>Block在内存中的存储</h3><p>数据段中的  <code>__NSGlobalBlock__</code>直到程序结束才会被回收，不过我们很少使用到<code>__NSGlobalBlock__</code>类型的block，因为这样使用block并没有什么意义。<br><code>__NSStackBlock__类</code>型的block存放在栈中，我们知道栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放，而在相同的作用域中定义block并且调用block似乎也多此一举。<br><code>__NSMallocBlock__</code>是在平时编码过程中最常使用到的。存放在堆中需要我们自己进行内存管理。<br><img src="/2019/02/11/block/block-store.jpeg" title="&nbsp;"></p>
<h4 id="Block-超出作用域还能存在的理由-amp-forwarding-的作用"><a href="#Block-超出作用域还能存在的理由-amp-forwarding-的作用" class="headerlink" title="Block 超出作用域还能存在的理由 &amp; __forwarding 的作用"></a>Block 超出作用域还能存在的理由 &amp; __forwarding 的作用</h4><p>配置在全局变量上的 Block, 从变量作用域外也可以通过指针安全的使用，但是设置在栈上的 Block，如果其所属的变量作用域结束，该Block就被废弃。如果<code>__block</code>（如：<strong>Block_byref_numBlock_0） 变量也会配置在栈上，则该`</strong>block`变量也会被废弃。将 Block 复制到堆上那么变量作用域结束时不受影响，</p>
<blockquote>
<p>impl.isa = &amp;_NSConcreteMallocBlock;<br>而 <code>__block</code> 结构体成员变量 <code>__forwarding</code> 可以实现无论 <code>__block</code> 变量配置在栈上还是堆上都能够正确的访问 <code>__block</code> 变量。通过 Block的复制，<code>__block</code>也一起复制到堆上，就可以同时访问栈上和堆上的<code>__block</code>，只要栈上的结构体实例成员变量 <code>__forwarding</code> 指向堆上的结构体实例。<br>在堆上的 Block 持有 <code>__block</code>变量，<code>__block</code>变量的引用计数 +1， <code>__block</code> 可以被多个 Block 持有。<br><img src="/2019/02/11/block/copy.png" title="&nbsp;"></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="block-转-c-源码"><a href="#block-转-c-源码" class="headerlink" title="block 转 c++ 源码"></a>block 转 c++ 源码</h3><p>如下代码 .h .m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//TestClang.h</span><br><span class="line">@interface TestClang : NSObject</span><br><span class="line">+ (void)testBlcok;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//TestClang.m</span><br><span class="line">#import &quot;TestClang.h&quot;</span><br><span class="line">static int numGlobel = 29;</span><br><span class="line">@implementation TestClang</span><br><span class="line">+ (void)testBlcok &#123;</span><br><span class="line">    //没有截获局部变量 __NSGlobalBlock__</span><br><span class="line">    void(^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">    NSLog(@&quot; block1 = %@&quot;, block1);</span><br><span class="line">    block1();</span><br><span class="line">    static int numStatic = 12;</span><br><span class="line">    int num = 10;</span><br><span class="line">    __block int numBlock = 19;</span><br><span class="line">    __block int numBlock2 = 30;</span><br><span class="line">    __block int numBlockTest = 30;</span><br><span class="line">        void(^block2)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;just a block === %d, numStatic = %d numGlobel = %d  numBlock=%d numBlock2=%d numBlockTest = %d&quot;, num,numStatic,numGlobel,numBlock,numBlock2,numBlockTest);</span><br><span class="line">            &#125;;</span><br><span class="line">    num = 33;</span><br><span class="line">    numStatic = 121;</span><br><span class="line">    numGlobel = 129;</span><br><span class="line">    numBlock = 22222;</span><br><span class="line">    block2();</span><br><span class="line">    NSLog(@&quot;block2 = %@&quot;, block2);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc TestClang.m<br>不要引用其他头文件，以免导出报Error<br>目录下生成了一个TestClang.cpp文件</p>
</blockquote>
<ul>
<li>testBlock 对应的方法变为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//_C_ 表示为类方法 _I_ 为实例方法</span><br><span class="line">static void _C_TestClang_testBlcok(Class self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    void(*block1)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_0((void *)__TestClang__testBlcok_block_func_0, &amp;__TestClang__testBlcok_block_desc_0_DATA));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_cf514e_mi_1, block1);</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">    static int numStatic = 12;</span><br><span class="line">    int num = 10;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlock_0 numBlock = &#123;(void*)0,(__Block_byref_numBlock_0 *)&amp;numBlock, 0, sizeof(__Block_byref_numBlock_0), 19&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlock2_1 numBlock2 = &#123;(void*)0,(__Block_byref_numBlock2_1 *)&amp;numBlock2, 0, sizeof(__Block_byref_numBlock2_1), 30&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_numBlockTest_2 numBlockTest = &#123;(void*)0,(__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 0, sizeof(__Block_byref_numBlockTest_2), 30&#125;;</span><br><span class="line"></span><br><span class="line">        void(*block2)(void) = ((void (*)())&amp;__TestClang__testBlcok_block_impl_1((void *)__TestClang__testBlcok_block_func_1, &amp;__TestClang__testBlcok_block_desc_1_DATA, num, &amp;numStatic, (__Block_byref_numBlock_0 *)&amp;numBlock, (__Block_byref_numBlock2_1 *)&amp;numBlock2, (__Block_byref_numBlockTest_2 *)&amp;numBlockTest, 570425344));</span><br><span class="line">    num = 33;</span><br><span class="line">    numStatic = 121;</span><br><span class="line">    numGlobel = 129;</span><br><span class="line">    (numBlock.__forwarding-&gt;numBlock) = 22222;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nc_qvb_bh854tz1y0p1hdk5y6km0000gn_T_TestClang_cf514e_mi_3, block2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[武功山游记]]></title>
    <link href="http://yoursite.com/2019/01/01/wugongshan/"/>
    <id>http://yoursite.com/2019/01/01/wugongshan/</id>
    <published>2018-12-31T18:14:59.000Z</published>
    <updated>2019-06-26T12:07:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="续：2018年12月31日，雪后，不一样的武功山"><a href="#续：2018年12月31日，雪后，不一样的武功山" class="headerlink" title="续：2018年12月31日，雪后，不一样的武功山~"></a>续：2018年12月31日，雪后，不一样的武功山~</h2><p>一直想去看冬季的武功山，期待满山白雪皑皑，雪景连接云海。何等壮观。我提出冬季上武功山露营，一家人心痒痒，但是担心大雪封山，临回家才确定上山。但是考虑到露营太冷，改为山脚景区泡温泉，次日上山。抵达景区温泉还下着雪，就着雪泡温泉的感觉真是冰火两重天。泡够时间就 “落荒而逃” ~</p>
<p>次日9点到达武功山脚下，买好门票缆车票。得知山中 -6℃ ，又买好口罩手套等。脚踩防滑链，踏着积雪，向着被白雪覆盖的武功山前进。<br><a id="more"></a></p>
<p><img src="http://qiniu.xuyanlan.com/wugongshan/123101.jpg" alt=""></p>
<p>做为难得一见雪景的南方人，看到雪就开始兴奋的拍拍拍。沉迷于雪景，粉色和雪景很搭~ 以为大雪封山行程阻塞，遂没带凹造型的纱裙。<br><img src="http://qiniu.xuyanlan.com/wugongshan/123102.jpg" alt=""></p>
<p>乘坐一级索道进入山中，入眼银装素裹，是从未见过的风景。不负严寒，不负此行。山中雾大，拍出的美十不及一。<br><img src="http://qiniu.xuyanlan.com/wugongshan/123103.jpg" alt=""><br><!-- ![](http://qiniu.xuyanlan.com/wugongshan/123104.jpg) --><br><img src="/2019/01/01/wugongshan/123104.jpg"><br><!-- ![](http://qiniu.xuyanlan.com/wugongshan/123105.jpg) --><br><img src="http://qiniu.xuyanlan.com/wugongshan/123106.jpg" alt=""><br><img src="/2019/01/01/wugongshan/123107.jpg"><br><!-- ![](http://qiniu.xuyanlan.com/wugongshan/123107.jpg) --><br><!-- ![](http://qiniu.xuyanlan.com/wugongshan/123108.jpg) --><br><img src="/2019/01/01/wugongshan/123108.jpg"><br><img src="/2019/01/01/wugongshan/123109.jpg"><br><!-- ![](http://qiniu.xuyanlan.com/wugongshan/123109.jpg) --><br><img src="http://qiniu.xuyanlan.com/wugongshan/123110.jpg" alt=""><br><img src="/2019/01/01/wugongshan/123105.jpg"><br>一路欣赏美景，记录美景，心中还是期待到达山顶，遇见云海。很快就走到了二级索道入口，人不多，不多时便乘上了二级索道。乘着二级索道上冲出云海，娇阳明媚，雪已基本融化，忍不住惊呼。<br><img src="http://qiniu.xuyanlan.com/wugongshan/123112.jpg" alt=""></p>
<p>最惊喜的是，最激动的是，又见云海！！！<br>干净大气，美不胜收。<br><img src="http://qiniu.xuyanlan.com/wugongshan/123111.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/123114.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/123115.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/123116.jpg" alt=""></p>
<p>自恋一下，哈哈。<br><img src="http://qiniu.xuyanlan.com/wugongshan/123117.jpg" alt=""></p>
<p>制作了一个简单的视频。</p>
<video controls="controls" height="360" width="640"><br>  <source src="http://qiniu.xuyanlan.com/wugongshan/1331m.mov"><br>Your browser does not support the video tag.<br></video>


<h2 id="续：2017五一三天徒步武功山，全程40公里。"><a href="#续：2017五一三天徒步武功山，全程40公里。" class="headerlink" title="续：2017五一三天徒步武功山，全程40公里。"></a>续：2017五一三天徒步武功山，全程40公里。</h2><p>出发：晚上从上海坐卧铺到萍乡有6趟车，到达萍乡7~9点。在车厢里你就会发现非常多一起去武功山得驴友，在车厢里就认识了几个妹子，其中有一个还是领队。后来的行程中也一直遇到，非常有缘。出发的气氛就很high。</p>
<p>第一天：上山10公里<br><img src="http://qiniu.xuyanlan.com/wugongshan/51wgs1.jpg" alt=""></p>
<p>第二天：山顶20+公里行走<br><img src="http://qiniu.xuyanlan.com/wugongshan/51wgs3.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/51wgs2.jpg" alt=""></p>
<p>第三天：上金顶后下山、晚上乘坐卧铺回上海</p>
<p>住宿：可自己重装背帐篷或者租，也有一些青旅。我们一行四人正好住一间青旅，晚上没有信号，就看夜景+打牌，哈哈</p>
<p>上次看到了日出日落，这次徒步没有特意去看~ 可惜这次没有云海相伴。</p>
<p><img src="http://qiniu.xuyanlan.com/wugongshan/51wgs4.jpg" alt=""></p>
<h2 id="初识武功山"><a href="#初识武功山" class="headerlink" title="初识武功山"></a>初识武功山</h2><p> 2016年国庆回江西发现一个风景美人不多的游玩好地方 – 武功山</p>
<p>云海很美，乘坐一级索道拍摄的风景,冲出云海的刹那很壮观<br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs.JPG" alt=""><br>半山腰风景<br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs1.JPG" alt=""><br>你可以选择坐二级索道上山顶，去坐索道还有一段路，路上风景也值得一走。<br><img src="http://qiniu.xuyanlan.com/wugongshan/wgsm.JPG" alt=""><br>到了山顶，山顶上只有几度，很冷，当时山下是穿短袖的。山顶上有帐篷租，很便宜。有些简易小摊位可以解决食物问题(泡面啥的，比较简陋)，<br>当然你也可以自己背些吃的和保暖衣服(必备)以及帐篷。第二天一大早快到日出的时候就会被叫醒去看日出O(∩_∩)O~</p>
<p><img src="http://qiniu.xuyanlan.com/wugongshan/wgs3.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs4.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs5.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs6.JPG" alt=""><br>清晨的风景，草长的好的时候可以滑草，没体验到，遗憾<br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs7.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/wugongshan/wgs8.JPG" alt=""><br><br><br>随便一拍都是美图，值得一登山顶，住一晚上，然后看日出。我们是从萍乡上去的，<br>还有一个路线是从安福上去(据说风景更好)。<br>总的来说性价比很高，我是乘坐索道和租帐篷以及吃饭从上山到下山大概不到500RMB。<br>当然如果你是徒步自己被帐篷和食物上去就不用花钱啦~不过主峰有1918米.</p>
<p>感觉去的很值，非常美，据说春秋去更佳，山顶上到时候会有雪，有机会还要再去(<em>^__^</em>)……</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="续：2018年12月31日，雪后，不一样的武功山"><a href="#续：2018年12月31日，雪后，不一样的武功山" class="headerlink" title="续：2018年12月31日，雪后，不一样的武功山~"></a>续：2018年12月31日，雪后，不一样的武功山~</h2><p>一直想去看冬季的武功山，期待满山白雪皑皑，雪景连接云海。何等壮观。我提出冬季上武功山露营，一家人心痒痒，但是担心大雪封山，临回家才确定上山。但是考虑到露营太冷，改为山脚景区泡温泉，次日上山。抵达景区温泉还下着雪，就着雪泡温泉的感觉真是冰火两重天。泡够时间就 “落荒而逃” ~</p>
<p>次日9点到达武功山脚下，买好门票缆车票。得知山中 -6℃ ，又买好口罩手套等。脚踩防滑链，踏着积雪，向着被白雪覆盖的武功山前进。<br></p>]]>
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[on-demand 资源下发]]></title>
    <link href="http://yoursite.com/2018/12/07/%E8%B5%84%E6%BA%90%E4%B8%8B%E5%8F%91/"/>
    <id>http://yoursite.com/2018/12/07/资源下发/</id>
    <published>2018-12-06T20:44:10.000Z</published>
    <updated>2019-02-15T09:51:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Apple-On-Demand-Resource"><a href="#Apple-On-Demand-Resource" class="headerlink" title="Apple On-Demand Resource"></a>Apple On-Demand Resource</h2><p> Xcode 可以给资源打 tag，被打 tag 的资源在打包时不会打到包内。需要时下载，测试时可以使用自己的服务器，但是发布到 AppStore 时需要托管到苹果的服务器。<br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html#//apple_ref/doc/uid/TP40015083-CH2-SW1" target="_blank" rel="noopener">苹果的 On-Demand Resource 文档</a></p>
<img src="/2018/12/07/资源下发/1.png" title="Xcode 设置tag">
<img src="/2018/12/07/资源下发/2.png" title="也可以直接点击资源设置 tag">
<h2 id="自建资源下发模块"><a href="#自建资源下发模块" class="headerlink" title="自建资源下发模块"></a>自建资源下发模块</h2><p>了解到了苹果 On-Demand Resource 机制，我们可以结合Resource Tags 下的资源不会打包到 ipa 包的特性。设计一套自己的下发机制。<br><a id="more"></a></p>
<h3 id="自动打包上传"><a href="#自动打包上传" class="headerlink" title="自动打包上传"></a>自动打包上传</h3><p>给需要下发的资源打上 tag 标签，xcode 打包时运行脚本上传 tag 包，生成 tag 配置信息 plist 文件，打包完成手动检查 md5 的一致性。<br><img src="/2018/12/07/资源下发/upload.jpg"></p>
<h3 id="按需下载模块设计"><a href="#按需下载模块设计" class="headerlink" title="按需下载模块设计"></a>按需下载模块设计</h3><img src="/2018/12/07/资源下发/download.jpg">
<p>接口和使用参照了苹果的 ondemand 相关接口</p>
<p>上面其实是第一版…. 中间面临新的需求，比如需要保持一个下载进度，让 download view 能随时取到。</p>
<h3 id="自动生成-plist"><a href="#自动生成-plist" class="headerlink" title="自动生成 plist"></a>自动生成 plist</h3><p>使用自带的 PlistBuddy 命令可以把 plist 更新<br><a href="http://www.mengyueping.com/2018/08/13/mac_PlistBuddy/" target="_blank" rel="noopener">PlistBuddy参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;start on-demand resource module&quot;</span><br><span class="line">GTagRootPath=&apos;./On-DemandResources&apos; //放 tag 资源包的路径，这里面我放的是已经打包好了 zip包，并标记为 tag resource</span><br><span class="line">echo On-DemandResources path = $GTagRootPath</span><br><span class="line">GTagPlistPath=&apos;./yourconfig.plist&apos; //plist 路径，先生成一个在工程里</span><br><span class="line">echo plist path = $&#123;GTagPlistPath&#125;</span><br><span class="line">GVerion=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$INFOPLIST_FILE&quot;)</span><br><span class="line">echo version = $&#123;GVerion&#125;</span><br><span class="line">GbundleId=$&#123;PRODUCT_BUNDLE_IDENTIFIER&#125;</span><br><span class="line">echo bundleID = $&#123;GbundleId&#125;</span><br><span class="line"></span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :bundleID $GbundleId&quot; $GTagPlistPath</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :version $GVerion&quot; $GTagPlistPath</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Delete :tags&quot; $GTagPlistPath</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Add :tags array&quot; $GTagPlistPath</span><br><span class="line"></span><br><span class="line">index=0</span><br><span class="line">for file in $GTagRootPath/*</span><br><span class="line">do</span><br><span class="line">if test -f $file</span><br><span class="line">then</span><br><span class="line">echo $file 是文件</span><br><span class="line">md5String=$(md5 -q $file)</span><br><span class="line">name=$(basename $file .zip)</span><br><span class="line">size=$(ls -l $file | awk &apos;&#123;print $5&#125;&apos;)</span><br><span class="line">echo size is $size</span><br><span class="line">/usr/libexec/PlistBuddy -c &apos;Add :tags: dict&apos; test.plist</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Add :tags:$index:name string $name&quot; $GTagPlistPath</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Add :tags:$index:size integer $size&quot; $GTagPlistPath</span><br><span class="line">echo $md5String</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Add :tags:$index:md5 string $md5String&quot; $GTagPlistPath</span><br><span class="line">index=$((index+1))</span><br><span class="line">fi</span><br><span class="line">if test -d $file</span><br><span class="line">then</span><br><span class="line">echo $file 是目录</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="check-和-上传脚本"><a href="#check-和-上传脚本" class="headerlink" title="check 和 上传脚本"></a>check 和 上传脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;start ondemand resource archive ......&quot;</span><br><span class="line"># check resource getInfo</span><br><span class="line">echo start get resource info</span><br><span class="line">curl -X POST \</span><br><span class="line">http://your.com/xxx \</span><br><span class="line">-H &apos;Postman-Token: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&apos; \</span><br><span class="line">-F version=1.0.0 \</span><br><span class="line">-F &apos;tagNames=[&quot;test&quot;]&apos;</span><br><span class="line"></span><br><span class="line">curl -X POST \</span><br><span class="line">http://your.com/xxxx \</span><br><span class="line">-H &apos;Content-Type:multipart/form-data; boundary=----ioqwiokjlfdlk198kdskl8oiidfn9mfdjmji9fd&apos; \</span><br><span class="line">-F version=1.0.0.10 \</span><br><span class="line">-F tagName=test \</span><br><span class="line">-F data=@/Users/xxx/test.zip</span><br><span class="line"></span><br><span class="line">echo &quot;end ondemand resource archive ......&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Apple-On-Demand-Resource"><a href="#Apple-On-Demand-Resource" class="headerlink" title="Apple On-Demand Resource"></a>Apple On-Demand Resource</h2><p> Xcode 可以给资源打 tag，被打 tag 的资源在打包时不会打到包内。需要时下载，测试时可以使用自己的服务器，但是发布到 AppStore 时需要托管到苹果的服务器。<br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html#//apple_ref/doc/uid/TP40015083-CH2-SW1" target="_blank" rel="noopener">苹果的 On-Demand Resource 文档</a></p>
<img src="/2018/12/07/资源下发/1.png" title="Xcode 设置tag">
<img src="/2018/12/07/资源下发/2.png" title="也可以直接点击资源设置 tag">
<h2 id="自建资源下发模块"><a href="#自建资源下发模块" class="headerlink" title="自建资源下发模块"></a>自建资源下发模块</h2><p>了解到了苹果 On-Demand Resource 机制，我们可以结合Resource Tags 下的资源不会打包到 ipa 包的特性。设计一套自己的下发机制。<br></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="功能设计" scheme="http://yoursite.com/categories/%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xcodeproj]]></title>
    <link href="http://yoursite.com/2018/11/30/xcodeproj/"/>
    <id>http://yoursite.com/2018/11/30/xcodeproj/</id>
    <published>2018-11-30T14:53:20.000Z</published>
    <updated>2018-12-07T02:59:38.000Z</updated>
    <content type="html"><![CDATA[<p>xcodeproj</p>
<p>xcodeproj 实际上是一个文件夹，打开后可以看到 project.pbxproj, xcuserdata, project.xcworkspace. </p>
<ul>
<li>project.pbxproj: “在 project 里的 project”，是 xcodeproj 最主要的文件</li>
<li>project.xcworkspace: 一个子文件夹，存储了用户 workspace 的相关信息</li>
<li>xcuserdata: 另外一个文件夹，里面也是用户相关的一些信息<a id="more"></a>
</li>
</ul>
<p>project.pbxproj 是 Next style 的 plist，描述了一个树状结构，最顶层是 RootElement.</p>
<ul>
<li>Root Element<ul>
<li>PBXBuildFile</li>
<li>PBXBuildPhase<ul>
<li>PBXAppleScriptBuildPhase</li>
<li>PBXCopyFilesBuildPhase</li>
<li>PBXFrameworksBuildPhase</li>
<li>PBXHeadersBuildPhase</li>
<li>PBXResourcesBuildPhase</li>
<li>PBXShellScriptBuildPhase</li>
<li>PBXSourcesBuildPhase</li>
</ul>
</li>
<li>PBXContainerItemProxy</li>
<li>PBXFileElement<ul>
<li>PBXFileReference</li>
<li>PBXGroup</li>
<li>PBXVariantGroup</li>
</ul>
</li>
<li>PBXTarget<ul>
<li>PBXAggregateTarget</li>
<li>PBXLegacyTarget</li>
<li>PBXNativeTarget</li>
</ul>
</li>
<li>PBXProject</li>
<li>PBXTargetDependency</li>
<li>XCBuildConfiguration</li>
<li>XCConfigurationList</li>
</ul>
</li>
</ul>
<p>除根节点外每一个节点都有一个 reference，节点间通过引用这个 reference 表明包含的关系.</p>
<p>下面是一个 pbxproj 文件的内容示例，objects 里包含有所有的子节点， rootObject 存储的是 PBXProject 的 reference.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// !$*UTF8*$!</span><br><span class="line">&#123;</span><br><span class="line">    archiveVersion = 1;</span><br><span class="line">    classes = &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    objectVersion = 45;</span><br><span class="line">    objects = &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    rootObject = 0867D690FE84028FC02AAC07 /* Project object */;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PBXProject 则包含了如配置，target 等信息，其中 mainGroup 就是我们打开项目看到的文件层级列表中最顶层的那个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">29B97313FDCFA39411CA2CEA /* Project object */ = &#123;</span><br><span class="line">        isa = PBXProject;</span><br><span class="line">        buildConfigurationList = C01FCF4E08A954540054247B /* Build configuration list for PBXProject &quot;XXX&quot; */;</span><br><span class="line">        compatibilityVersion = &quot;Xcode 2.4&quot;;</span><br><span class="line">        developmentRegion = English;</span><br><span class="line">        hasScannedForEncodings = 1;</span><br><span class="line">        knownRegions = (</span><br><span class="line">                English,</span><br><span class="line">                Japanese,</span><br><span class="line">                French,</span><br><span class="line">                German,</span><br><span class="line">                en,</span><br><span class="line">        );</span><br><span class="line">        mainGroup = 29B97314FDCFA39411CA2CEA /* XXX*/;</span><br><span class="line">        projectDirPath = &quot;&quot;;</span><br><span class="line">        projectRoot = &quot;&quot;;</span><br><span class="line">        targets = (</span><br><span class="line">             8D1107260486CEB800E47090 /* XXX*/,</span><br><span class="line">        );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>PBXGroup 的 children 字段的值是一个 reference 数组, reference 可以指向另外一个 PBXGroup，也可以指向一个文件节点 PBXFileReference<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">015554500155562000000001 /* SlimmingResouces */ = &#123;</span><br><span class="line">	isa = PBXGroup;</span><br><span class="line">	children = (</span><br><span class="line">		01555120015554C000000001 /* Help.zip */,</span><br><span class="line">	);</span><br><span class="line">	name = SlimmingResouces;</span><br><span class="line">	sourceTree = &quot;&lt;group&gt;&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>添加一个文件的过程：</p>
<ul>
<li>创建一个 PBXFileReference 对象 fileRef</li>
<li>创建或者查找到一个 PBXGroup，将 fileRef 加入</li>
<li>用 fileRef 创建一个 PBXBuildFile buildFile</li>
<li>找到待加入的 PBXNativeTarget target</li>
<li>找到 target 的 PBXResourcesBuildPhase 将 fileRef 加入<br></li>
</ul>
<h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p><a href="http://www.monobjc.net/xcode-project-file-format.html" target="_blank" rel="noopener">http://www.monobjc.net/xcode-project-file-format.html</a></p>
<p><a href="https://github.com/google/zopfli" target="_blank" rel="noopener">https://github.com/google/zopfli</a></p>
<p><a href="https://github.com/google/brotli" target="_blank" rel="noopener">https://github.com/google/brotli</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>xcodeproj</p>
<p>xcodeproj 实际上是一个文件夹，打开后可以看到 project.pbxproj, xcuserdata, project.xcworkspace. </p>
<ul>
<li>project.pbxproj: “在 project 里的 project”，是 xcodeproj 最主要的文件</li>
<li>project.xcworkspace: 一个子文件夹，存储了用户 workspace 的相关信息</li>
<li>xcuserdata: 另外一个文件夹，里面也是用户相关的一些信息</li></ul>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[冲绳四日三晚游记]]></title>
    <link href="http://yoursite.com/2018/09/12/%E5%86%B2%E7%BB%B3%E5%9B%9B%E6%97%A5%E4%B8%89%E6%99%9A%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/09/12/冲绳四日三晚游记/</id>
    <published>2018-09-11T18:06:30.000Z</published>
    <updated>2019-01-07T06:58:34.000Z</updated>
    <content type="html"><![CDATA[<p>行程时间： 9月7日 - 9月10日<br>提前一个月的时间定了吉祥航空的往返航班，2700左右/人。出发时下午5点，回程是下午7点。<br>行程酒店：美国村门巴公寓酒店，酒店外就是沙滩。<br>冲绳9月份是台风季，天气说不准，最好提前做下攻略。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>启程，第一天出发的时间是北京时间5点，到冲绳大概2个小时，不过因为冲绳是早一个小时的，所以到冲绳是当地时间晚上8点了。预订的接机去美国村的酒店，400RMB。<br>抵达冲绳从机场出来就感觉非常干净，各种建筑街道啥的都非常干净，各种基础设施做的也很贴心。约的日本的司机来接机的，人很有礼貌，会一点英语, 大概花了50分钟左右到美国村。入住之后就去觅食，找到了上一波推荐去的一家叫 xx食堂的店，吃了猪豚骨饭，另外在冲绳大众点评也挺好用(<em>^__^</em>)。<br>美国村夜景<br><img src="http://qiniu.xuyanlan.com/chongSheng/9701.JPG" alt=""></p>
<a id="more"></a>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>第二天的清晨景色~ 天气很好~ 开心~<br><img src="http://qiniu.xuyanlan.com/chongSheng/9803.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/9804.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/9802.JPG" alt=""></p>
<video controls="controls" height="360" width="640"><br>  <source src="http://qiniu.xuyanlan.com/chongSheng/IMG_0323.mov"><br>Your browser does not support the video tag.<br></video>

<p>第二天安排：部濑名海中公园 -&gt; 残波狎 -&gt; 美军基地展望台</p>
<p>第一天晚上休整完已经是冲绳的10点了，然后发现第二天的行程还没定！只能在酒店附近瞎晃一天的样子，而且看起来第二天天气应该不错，觉得还是应该出去玩儿，这个时候多亏之前认真做了攻略，记得在马蜂窝上有一个当天都可以订包车行程的项目，咨询在线客服发现客服9点已经下班了，不管三七二十一就直接下单了。还好下单完几分钟后就有客服妹子加了微信，跟她约好了第二天的行程和司机接送时间，十分钟搞定！包车8小时1049RMB，日文司机。其实这个非常划算，比自己打车便宜很多，打车去部濑名还中公园一个小时就得要500多RMB，而且从那边回来是很难打到车的，墙裂推荐包车！！！<br>主要游玩点时间图<br><img src="http://qiniu.xuyanlan.com/chongSheng/9801.jpg" alt=""><br>这个图上的时间非常准确，google地图上显示的堵车在我来说根本不叫堵车，非常友好，哈哈哈。<br>幸好约好了包车行程，否则一天在美国村玩儿真是有点浪费啦，司机9店准时在酒店门口等着，是一个50多岁的大叔，人非常好，一直用 google 翻译跟我们聊天，而且他还去过两次上海，不过是三十多年前，会说几个中文词，行程很愉快。包车这块没有其他的附加费用。</p>
<h4 id="部濑名海中公园"><a href="#部濑名海中公园" class="headerlink" title="部濑名海中公园"></a>部濑名海中公园</h4><p>推荐游玩时间：3-5小时<br>网上很多人推荐必玩的项目，玻璃底船和海中展望塔，买了套票2060日元。这边还有很多其他项目，之前做攻略的时候想玩的浮潜和海上拖拽伞，都比单次报团去参加便宜很多，而且美国村有的项目还不接送。所以能在海中公园的行程中包含也是非常不错的选择。可惜我没有安排去其他活动，其实时间上来说完全够的，遗憾~~<br><img src="http://qiniu.xuyanlan.com/chongSheng/9810.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/9805.JPG" alt=""><br>第一张图就是海底展望塔啦，最后一张图就是坐玻璃底船拍到的，船有点晃，行程20分钟，就是直接看海里的鱼，还能看到珊瑚之类的。其实海中展望塔也只是去海底透过玻璃窗口看海里的景色，不过也算值得票价拉。而且周边的景色很好~2个小时很快就过去了，在点评上看了一下附近的美食，有很多家，找了一家评价不错的餐厅吃饭，出了公园司机大叔就开着车来接我们去吃饭了，我感觉他应该是很多时间都在车上的，真的很负责~<br>午餐：味道很好 3700日元左右<br><img src="http://qiniu.xuyanlan.com/chongSheng/9807.JPG" alt=""></p>
<h4 id="残波狎"><a href="#残波狎" class="headerlink" title="残波狎"></a>残波狎</h4><p>推荐游玩时间：1-2小时<br>残波狎景色很好，可以沿着2KM长的海岸线慢慢的走，吹吹风。快到的时候下起了大雨，司机大叔让我们在车里等几分钟，几分钟之后雨就停了，不过司机大叔还是给了我们两把伞，冲绳的出租车里面都备有伞，所以如果是包车，完全不需要自己带伞的哦。<br><img src="/2018/09/12/冲绳四日三晚游记/9806.JPG"></p>
<h4 id="美军基地展望台"><a href="#美军基地展望台" class="headerlink" title="美军基地展望台"></a>美军基地展望台</h4><p>emm… 这次行程最想去的是上面的两个地方，这个美军基地只是顺便来看下，来了之后发现是在美军基地对面的一个楼上，有一个望远镜，投币100日元可以看两分钟对面~ 感觉可以把时间放在海中公园的游玩上，不是很有意思就在楼上喝了一杯咖啡，休息了一下就返回酒店啦~<br><img src="http://qiniu.xuyanlan.com/chongSheng/9808.JPG" alt=""></p>
<h4 id="美国村日落海滩"><a href="#美国村日落海滩" class="headerlink" title="美国村日落海滩"></a>美国村日落海滩</h4><p>预计回程是5点，早了二十多分钟回来，趁着天早去酒店旁边的沙滩玩儿，游游泳，看日落，不过天气不是很适合看日落，云层很厚，不过坐着吹吹海风还是不错哦~<br><img src="http://qiniu.xuyanlan.com/chongSheng/9811.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/9809.JPG" alt=""></p>
<h4 id="药妆店购物"><a href="#药妆店购物" class="headerlink" title="药妆店购物"></a>药妆店购物</h4><p>美国村附近的药妆店很多，人也巨多，帮朋友带了些药妆，购物到快十点~ 泪目。</p>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>第三天安排：万座毛 -&gt; 美丽水族馆 -&gt; 古宇利岛<br>和同事一行9人包了一辆车，10小时行程，因为还有两个同事在那霸市区，多了一个小时车程，而且水族馆和古宇利岛比较远，所以安排的是10小时的包车行程，行程包车2088RMB，水族馆的门票在水族馆附近的便利店买的打折票，折后1660日元，原价1860日元，去的朋友可以问问司机或者知道的人看看可以在哪个便利店买打折票哦~不是所有的便利店都会打折哒。算下来人均333RMB。如果是报大巴团的话是199RMB含门票，行程和游玩点游玩时间差不多。只不过包车比较自由啦~</p>
<h4 id="万座毛"><a href="#万座毛" class="headerlink" title="万座毛"></a>万座毛</h4><p>游玩时间：20分钟<br>万座毛如果天气阳光好的话去看非常漂亮，我们比较幸运的是赶在大雨来临之前到了万座毛，只不过万座毛也就是和拍拍照看一看，活动范围只是一个大概几百平米的草坪而已啦~ 不过我们真的太幸运，天气巨好，海水巨蓝。附上美图~<br><img src="http://qiniu.xuyanlan.com/chongSheng/9901.JPG" alt=""><br>离开不到几分钟就开始下大雨了，所以万座毛这个地方还是非常看天气的，运气好的话就能看到美景哦~</p>
<h4 id="海洋博公园"><a href="#海洋博公园" class="headerlink" title="海洋博公园"></a>海洋博公园</h4><p>游玩时间：3-4小时<br>之前没有去过任何海族馆，进到海水族馆很兴奋，看到很多没见过的五颜六色的鱼、海龟、海牛…黑潮海水族馆前的玻璃面板看着各种 中午的午饭也是在海水族馆解决的，稍微错开一点饭点去吃的话是不错的选择，我们在看完1：00的海豚表演之后去吃的，就是在黑潮海水族馆旁边的咖啡馆吃的哦，不过贴着玻璃的座位需要预订的，怎么预定没有提前了解，有需要的话可以提前了解下。价格也不贵的，基本是600日元以下的主食、饮料。意面味道还不错~。海族馆可以反复进出，不过你如果想在出口进入的话可以让工作人员给你的手上盖个海豚章，就可以从出口处进去啦，黑潮海水族馆离出口比较近，所以我们吃饭的时候就是从出口进入的。<br>海水族馆的各种小可爱<br><img src="http://qiniu.xuyanlan.com/chongSheng/9902.JPG" alt=""><br>海豚表演，海豚很听话，很可爱，但是看的时候莫名心疼啊<br><img src="http://qiniu.xuyanlan.com/chongSheng/9903.JPG" alt=""></p>
<h4 id="古宇利岛"><a href="#古宇利岛" class="headerlink" title="古宇利岛"></a>古宇利岛</h4><p>游玩时间：45分钟<br>古宇利岛是冲绳的一个离岛，有一个桥能直接去岛上而闻名，可以在岛上的沙滩上玩一玩，游游泳，游乐设施相对比较简陋。我们去的时候下雨了，大部分人没带泳衣之类的，所以只能撑伞在海边走一走。在桥上看的时候海水很蓝，如果是大晴天的话应该会非常美了，可惜这次没有那么幸运惹~哼唧唧 o(╥﹏╥)o，附上两张对比图。<br>我去的时候的景色<br><img src="http://qiniu.xuyanlan.com/chongSheng/9904.JPG" alt=""><br>人家去的时候的景色<br><img src="http://qiniu.xuyanlan.com/chongSheng/9905.jpg" alt=""></p>
<h4 id="DFS购物"><a href="#DFS购物" class="headerlink" title="DFS购物"></a>DFS购物</h4><p>同行同事住在 DFS 附近，我们正好就到 DFS 下车，帮自己和朋友买了些护肤品~ (<em>^__^</em>)</p>
<h4 id="美国村"><a href="#美国村" class="headerlink" title="美国村"></a>美国村</h4><p>住的地方附近也很有特色，很喜欢那种感觉，很舒服的小镇。<br><img src="http://qiniu.xuyanlan.com/chongSheng/1.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/2.JPG" alt=""></p>
<h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>下午7点的飞机，没有特别的行程安排，10点退房之后就打车去了永旺商场，出租车的司机师傅的中文很好，在跟着中国留学生学中文，聊了一路。买了些小东西和特产，在一个宫崎骏电影的小玩具店里买到很多喜欢的手指玩偶，还有一些糕点。<br><img src="http://qiniu.xuyanlan.com/chongSheng/91001.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/91002.JPG" alt=""><br>买完特产想直接坐轻轨去机场，打算走路去最近的轻轨站台，结果。。。拖着行李走了一个小时，后来又回到了买特产的商场（永旺）打车打机场。不推荐使用google map 来查乘车路线，可以下载日本的交通类APP。<br>花了半小时走到废弃的站台,在某个不知名的村里迷路了很久<br><img src="http://qiniu.xuyanlan.com/chongSheng/91003.JPG" alt=""><br><img src="http://qiniu.xuyanlan.com/chongSheng/91004.JPG" alt=""><br>那霸机场真的很小，只有两个区可以值机，而且只能在起飞前两小时开始值机，去早了也只能等了。</p>
<h3 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h3><p>行前必备品清单：</p>
<ul>
<li>4G 电话卡，淘宝就可以买了，网速不错，流量超了会限速的很厉害。不过你正常用不看视频直播之类的还行，而且酒店一般会有 WIFI。</li>
<li>插座转接口，有的酒店会提供，但是我去的公寓酒店并没有，还好自己带了一个。冲绳是两孔的插座，所以我带的是两孔转三孔的，然后带了三孔排插。</li>
<li>少量现金，我们三个人换了5W日元，结果回来的时候还有1W6没用完，基本是用来在餐厅吃饭和打车。很多超市和便利店都可以用支付宝或者微信，其实打车也可以用微信的哦，不过是蓝色车顶的那种。</li>
<li>防晒用品</li>
</ul>
<p>结算：<br>机票：8236RMB 酒店：4751RMB 包车：2400RMB 打车+吃饭：2500RMB 购物+随手礼：5500RMB<br>总计花费：23387RMB</p>
<p>冲绳 地图<br><img src="http://qiniu.xuyanlan.com/chongSheng/3.JPG" alt=""></p>
<p>合集视频</p>
<video controls="controls" height="360" width="640"><br>  <source src="http://qiniu.xuyanlan.com/chongSheng/vue_video_cache_filtered_spliced.mov"><br></video>
]]></content>
    <summary type="html">
    <![CDATA[<p>行程时间： 9月7日 - 9月10日<br>提前一个月的时间定了吉祥航空的往返航班，2700左右/人。出发时下午5点，回程是下午7点。<br>行程酒店：美国村门巴公寓酒店，酒店外就是沙滩。<br>冲绳9月份是台风季，天气说不准，最好提前做下攻略。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>启程，第一天出发的时间是北京时间5点，到冲绳大概2个小时，不过因为冲绳是早一个小时的，所以到冲绳是当地时间晚上8点了。预订的接机去美国村的酒店，400RMB。<br>抵达冲绳从机场出来就感觉非常干净，各种建筑街道啥的都非常干净，各种基础设施做的也很贴心。约的日本的司机来接机的，人很有礼貌，会一点英语, 大概花了50分钟左右到美国村。入住之后就去觅食，找到了上一波推荐去的一家叫 xx食堂的店，吃了猪豚骨饭，另外在冲绳大众点评也挺好用(<em>^__^</em>)。<br>美国村夜景<br><img src="http://qiniu.xuyanlan.com/chongSheng/9701.JPG" alt=""></p>]]>
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Recording Animation]]></title>
    <link href="http://yoursite.com/2018/08/23/Recording-Animation/"/>
    <id>http://yoursite.com/2018/08/23/Recording-Animation/</id>
    <published>2018-08-22T18:34:37.000Z</published>
    <updated>2018-08-22T10:43:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="记录一次录音动画实现"><a href="#记录一次录音动画实现" class="headerlink" title="记录一次录音动画实现"></a>记录一次录音动画实现</h3><p>需求：根据音量大小实现一个录音波形动画，因为拿到的音量大小在10-30之间，所以会已30为最大值。其实未录音和录音之后会有另外的lottie动画，再此记录的只是录音中的动画。</p>
<img src="/2018/08/23/Recording-Animation/test.gif" title="效果图">
<p><a href="https://github.com/waterXu/RecordingAnimation" target="_blank" rel="noopener">demo 地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="记录一次录音动画实现"><a href="#记录一次录音动画实现" class="headerlink" title="记录一次录音动画实现"></a>记录一次录音动画实现</h3><p>需求：根据音量大小实现一个录音波形动画，因为拿到的音量大小在10-30之间，]]>
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渐变圆环实现记录]]></title>
    <link href="http://yoursite.com/2018/07/03/%E6%B8%90%E5%8F%98%E5%9C%86%E7%8E%AF%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/03/渐变圆环实现记录/</id>
    <published>2018-07-02T16:55:36.000Z</published>
    <updated>2018-08-06T11:25:45.000Z</updated>
    <content type="html"><![CDATA[<p>先了解下坐标系<br><img src="/2018/07/03/渐变圆环实现记录/gradient-point.png" title="iOS layer坐标系"><br>position属性是决定子layer在父layer上的位置，默认为（0，0）。其次，anchorPoint属性是决定子layer上的哪个点会在position所指定的位置。<br><a id="more"></a><br>最近需求里实现一个灯光亮度、开关效果<br><img src="/2018/07/03/渐变圆环实现记录/off-ring.png" title="关灯状态"><br><img src="/2018/07/03/渐变圆环实现记录/on-rings.png" title="开灯状态，5级亮度（环个数代表亮度级数）"></p>
<p>代码示例：VSColorWithHexString为16进制颜色值转UIColor的宏。<br>.h文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">typedef NS_ENUM(NSInteger, VSSceneControlViewType)&#123;</span><br><span class="line">    VSSceneControlViewTypeOn = 1,</span><br><span class="line">    VSSceneControlViewTypeOff = 2</span><br><span class="line">&#125;;</span><br><span class="line">@interface VSSceneControlView : UIView</span><br><span class="line">@property (nonatomic, strong) UIColor *offColor;</span><br><span class="line">@property (nonatomic, strong) UIColor *startColor;</span><br><span class="line">@property (nonatomic, strong) UIColor *endColor;</span><br><span class="line">@property (nonatomic, assign) NSInteger layerCount; //光圈个数，用于计算渐变等级,默认为5</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithRadius:(CGFloat)radius borderWidth:(CGFloat)borderWidth;</span><br><span class="line">- (void)controlOnWithRingCount:(NSInteger)ringCount; //开灯亮度</span><br><span class="line">- (void)controlOff; //关闭</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br>.m实现文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;VSSceneControlView.h&quot;</span><br><span class="line"></span><br><span class="line">@interface VSSceneControlView()</span><br><span class="line">@property (nonatomic, strong) UIImageView *centerIcon;</span><br><span class="line">@property (nonatomic, assign) CGFloat radius;</span><br><span class="line">@property (nonatomic, assign) CGFloat borderWidth;</span><br><span class="line">@property (nonatomic, assign) VSSceneControlViewType type;</span><br><span class="line">@property (nonatomic, strong) NSArray *layerArray;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation VSSceneControlView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithRadius:(CGFloat)radius borderWidth:(CGFloat)borderWidth &#123;</span><br><span class="line">    if(self = [super init]) &#123;</span><br><span class="line">        _radius = radius;</span><br><span class="line">        _type = VSSceneControlViewTypeOff;</span><br><span class="line">        _borderWidth = borderWidth;</span><br><span class="line">        _layerCount = 5;</span><br><span class="line">        _startColor = VSColorWithHexString(@&quot;FA9D24&quot;);</span><br><span class="line">        _endColor = VSColorWithHexString(@&quot;FCD96A&quot;);</span><br><span class="line">        _offColor = VSColorWithHexString(@&quot;F4F4F4&quot;);</span><br><span class="line">        [self commonInit];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)commonInit&#123;</span><br><span class="line">    _centerIcon = [[UIImageView alloc] init];</span><br><span class="line">    _centerIcon.contentMode = UIViewContentModeScaleAspectFill;</span><br><span class="line">    [self addSubview:_centerIcon];</span><br><span class="line">    [_centerIcon mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.center.equalTo(@0);</span><br><span class="line">        make.width.equalTo(@57);</span><br><span class="line">        make.height.equalTo(@57);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (void)clearLayers &#123;</span><br><span class="line">    for (CALayer *layer in self.layerArray) &#123;</span><br><span class="line">        [layer removeAllAnimations];</span><br><span class="line">        [layer removeFromSuperlayer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)controlOnWithRingCount:(NSInteger)ringCount &#123;</span><br><span class="line">    [self clearLayers];</span><br><span class="line">    _centerIcon.image = [UIImage imageNamed:@&quot;scene_on&quot;];</span><br><span class="line">    NSMutableArray *layers = [NSMutableArray array];</span><br><span class="line">    NSInteger count = (ringCount &gt; self.layerCount) ? self.layerCount : ringCount;</span><br><span class="line">    count = (count == 0) ? 1 : count;</span><br><span class="line">    NSArray&lt;NSNumber *&gt; *opacitys = @[@1,@0.5,@0.3,@0.15,@0.06];</span><br><span class="line">    for (int i = 1 ;i &lt;= count; i++) &#123;</span><br><span class="line">        CAShapeLayer *ringLayer = [[CAShapeLayer alloc] init];</span><br><span class="line">        ringLayer.frame = self.bounds;</span><br><span class="line">        ringLayer.fillColor = [UIColor clearColor].CGColor;</span><br><span class="line">        ringLayer.strokeColor = self.offColor.CGColor;</span><br><span class="line">        ringLayer.lineCap = kCALineCapButt;</span><br><span class="line">        ringLayer.lineJoin = kCALineJoinRound;</span><br><span class="line">        ringLayer.lineWidth = self.borderWidth;</span><br><span class="line">        ringLayer.strokeStart = 0;</span><br><span class="line">        ringLayer.strokeEnd = 1;</span><br><span class="line">        CGFloat radius = (self.radius + (i-1) * _borderWidth);</span><br><span class="line">        UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.radius, self.radius) radius:radius startAngle:0 endAngle:2 * M_PI clockwise:NO];</span><br><span class="line">        ringLayer.path = path.CGPath;</span><br><span class="line">        </span><br><span class="line">        CALayer *layer = [[CALayer alloc] init];</span><br><span class="line">        layer.frame = self.bounds;</span><br><span class="line">        [layer setMask:ringLayer];</span><br><span class="line">        </span><br><span class="line">        CAGradientLayer *gradientLayer = [CAGradientLayer layer];</span><br><span class="line">        gradientLayer.frame = CGRectMake(0, 0, (radius + _borderWidth) * 2 , (radius + _borderWidth) * 2);</span><br><span class="line">        gradientLayer.position = CGPointMake(self.radiu, self.radius);</span><br><span class="line">        // 颜色分配</span><br><span class="line">        [gradientLayer setColors:[NSArray arrayWithObjects:(id)self.startColor.CGColor,(id)self.endColor.CGColor, nil]];</span><br><span class="line">        gradientLayer.opacity = [opacitys[i-1] floatValue];</span><br><span class="line">        [gradientLayer setLocations:@[@0.5]]; // 颜色分割线</span><br><span class="line">        [gradientLayer setStartPoint:CGPointMake(0, 0)]; //起点</span><br><span class="line">        [gradientLayer setEndPoint:CGPointMake(0, 1)]; //结束点 该效果从上垂直向下渐变，（0，0）-（1，1）则是左上斜向右下</span><br><span class="line">        [layer addSublayer:gradientLayer];</span><br><span class="line">        </span><br><span class="line">        [self.layer addSublayer:layer];</span><br><span class="line">        [layers addObject:layer];</span><br><span class="line">    &#125;</span><br><span class="line">    self.layerArray = [layers copy];</span><br><span class="line">    _type = VSSceneControlViewTypeOn;</span><br><span class="line">&#125;</span><br><span class="line">- (void)controlOff &#123;</span><br><span class="line">    [self clearLayers];</span><br><span class="line">    _centerIcon.image = [UIImage imageNamed:@&quot;scene_off&quot;];</span><br><span class="line">    CAShapeLayer *offLayer = [[CAShapeLayer alloc] init];</span><br><span class="line">    offLayer.frame = self.bounds;</span><br><span class="line">    offLayer.fillColor = [UIColor clearColor].CGColor;</span><br><span class="line">    offLayer.strokeColor = self.offColor.CGColor;</span><br><span class="line">    offLayer.lineCap = kCALineCapButt;</span><br><span class="line">    offLayer.lineJoin = kCALineJoinRound;</span><br><span class="line">    offLayer.lineWidth = self.borderWidth;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.radius, self.radius) radius:self.radius startAngle:0 endAngle:2 * M_PI clockwise:NO];</span><br><span class="line">    offLayer.path = path.CGPath;</span><br><span class="line">    [self.layer addSublayer:offLayer];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *layers = [NSMutableArray array];</span><br><span class="line">    [layers addObject:offLayer];</span><br><span class="line">    self.layerArray = [layers copy];</span><br><span class="line">    _type = VSSceneControlViewTypeOn;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先了解下坐标系<br><img src="/2018/07/03/渐变圆环实现记录/gradient-point.png" title="iOS layer坐标系"><br>position属性是决定子layer在父layer上的位置，默认为（0，0）。其次，anchorPoint属性是决定子layer上的哪个点会在position所指定的位置。<br></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[度户外九龙大峡谷徒步]]></title>
    <link href="http://yoursite.com/2018/05/19/%E5%BA%A6%E6%88%B7%E5%A4%96%E4%B9%9D%E9%BE%99%E5%A4%A7%E5%B3%A1%E8%B0%B7%E5%BE%92%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/05/19/度户外九龙大峡谷徒步/</id>
    <published>2018-05-19T11:15:55.000Z</published>
    <updated>2018-05-25T03:19:36.000Z</updated>
    <content type="html"><![CDATA[<p>有其他小伙伴写了游记，这里做个记录~ (<em>^__^</em>) 嘻嘻……<br><a href="https://mp.weixin.qq.com/s/7bYSCwy6hpc5VJdFdLn24Q" target="_blank" rel="noopener">度户外·半满白草畔</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有其他小伙伴写了游记，这里做个记录~ (<em>^__^</em>) 嘻嘻……<br><a href="https://mp.weixin.qq.com/s/7bYSCwy6hpc5VJdFdLn24Q" target="_blank" rel="noopener">度户外]]>
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[故宫-长城两日游攻略]]></title>
    <link href="http://yoursite.com/2018/05/14/%E6%95%85%E5%AE%AB-%E9%95%BF%E5%9F%8E%E4%B8%A4%E6%97%A5%E6%B8%B8/"/>
    <id>http://yoursite.com/2018/05/14/故宫-长城两日游/</id>
    <published>2018-05-14T10:33:35.000Z</published>
    <updated>2018-10-31T11:51:39.000Z</updated>
    <content type="html"><![CDATA[<p>时间： 5月12日、5月13日 （非高峰期）<br>购票方式：<br>   故宫：网上购门票 + 珍宝馆 + 珠宝馆 78元/人，直接刷身份证进入。<br>   八达岭长城：网上购大门票 + 往返直通车 87元/人</p>
<h4 id="故宫"><a href="#故宫" class="headerlink" title="故宫"></a>故宫</h4><p>特别注意需要提前准备的：<br>    1：下载一个故宫的讲解App（故宫博物馆三毛游）不知道还有没有其他好用的，没有特别去筛选。完了就预先下载好所有的讲解音频文件，这个app解锁所有的讲解需要15元，在到达不同地点会自动播放相应的讲解，还能看见当前的位置，真的是东西南北都分不清的路痴的福音。回来的时候还听到一个妹纸说找不到钟表馆啊，票白买啦！！(<em>^__^</em>) 嘻嘻……，所以下个辅助App还是很方便的。不然得去租故宫的电子讲解器（20元），人比较多，而且走的时候还要还。<br>    2：携带中午的午餐，补充体力<br>    3：充电宝<br><a id="more"></a><br>故宫布局截图：<br><img src="http://qiniu.xuyanlan.com/greatWall/jietu.png" alt=""><br>路线：午门（7）-&gt;珠宝馆（51）-&gt;珍妃井（58）-&gt;钟表馆（48）-&gt;东六宫（34-39）-&gt;御花园（40）-&gt;神武门（59）-&gt;西六宫（28-33）-&gt;坤宁宫-&gt;太和门（最后走中线回到午门26-8）<br>时间：上午9点-&gt;下午两点<br>天气：阴天<br>从午门到天安门，因为不能直接从午门到天安门（只有进场的游客可以，也就是说只能从天安门到午门），所以我们从东华门绕道到天安门都快下午三点了。<br>计划是在8：30开门之前到午门检票口，但是实际上9点才到检票口，因为是非高峰节假日，人不算特别多，基本上检票口都是一队队的旅游团在整队型，有好几个检票口都没人，我们进去都没有排队。<br>进入之后发现大部分人是往太和殿方向走的，所以这条线的人非常多，所以我们进入之后马上去右侧的钟表馆方向，过去就发现人很少的，一路上仔细的走走看看，听听讲解，拍拍照，不需要和其他人挤着。看完珠宝馆和钟表馆之后就可以开始逛东六宫，逛完之后就中午12点了，可以找个地方吃带过来的零食面包啥的当午餐，故宫里面有WiFi，只是不是很稳定，经常掉线，不过速度还是很快的。用完午饭就可以去御花园，然后在神武门的城墙上走一圈再去西六宫，最后走完西六宫之后再从坤宁宫往太和门走，这个时候人没有刚来的时候人多，但是基本上都是只能在门外看着，拍个照，是不能进去的。<br>到天安门、天安门广场走一走逛一逛就到5点了。因为预报会有雷阵雨，所以就先回去了。</p>
<p>总结：按照这个路线走的话，基本上走遍了故宫，在非大型假日的时候走一走还是很悠闲的，而且还能配合讲解器，有些比较出名的宫殿这个App还会加一些历史的讲解，其他宫殿基本上讲解的就是宫殿内放的介绍碑的内容。因为没有租过故宫的讲解器，所以没有对比。</p>
<p>组图<br>从东华门前往午门<br><img src="http://qiniu.xuyanlan.com/greatWall/51202.jpg" alt=""><br>检票之后人还是挺多<br><img src="http://qiniu.xuyanlan.com/greatWall/51203.jpg" alt=""><br>珠宝馆<br><img src="http://qiniu.xuyanlan.com/greatWall/512012.jpg" alt=""><br>从右侧出发可以拍到空街<br><img src="http://qiniu.xuyanlan.com/greatWall/51201.jpg" alt=""><br>御花园<br><img src="http://qiniu.xuyanlan.com/greatWall/flower.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/greatWall/51206.jpg" alt=""><br>神武门<br><img src="http://qiniu.xuyanlan.com/greatWall/51207.jpg" alt=""><br>皇帝的工作室，太和殿外围拦住了，只能远远的看一下内里。坤宁宫<br><img src="http://qiniu.xuyanlan.com/greatWall/51205.jpg" alt=""><br>太和殿<br><img src="http://qiniu.xuyanlan.com/greatWall/51204.jpg" alt=""><br>中午往午门方向走人相对少了<br><img src="http://qiniu.xuyanlan.com/greatWall/51208.jpg" alt=""><br>太和殿广场<br><img src="http://qiniu.xuyanlan.com/greatWall/51209.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/greatWall/512010.jpg" alt=""><br>天安门<br><img src="http://qiniu.xuyanlan.com/greatWall/512011.jpg" alt=""></p>
<h4 id="八达岭长城"><a href="#八达岭长城" class="headerlink" title="八达岭长城"></a>八达岭长城</h4><p>天气：晴天 30°左右<br>算是报了一个小团，为了方便乘车，如果自己包车或者出租车前往基本上要600+。买直通车的票40元一人还送导游服务，选择了早上8点在北土城地铁站集合，上午9点多抵达八达岭长城，因为这次只有2个小时的游览时间，所以买了缆车，这也算是不好的一点吧，时间比较紧张，缆车往返票140，单程100。因为人不是特别多，9点半就上了长城，缆车（可承载8人）只要&lt;5分钟就到了。我们体力比较好，走到了北八楼之后往南四楼方向一直走，然后乘坐南四楼的缆车（可承载120人）下去，正好是2个小时。<br>如下是当天长城风景，人还是挺多的。不过南四楼方向人相对较少，北九到北十二人更少了，因为还得返回南/北四乘坐缆车，也可以纯徒步上下长城，感觉也不是很费时，但是这次时间比较紧张，所以没有全部走一遍。<br><img src="http://qiniu.xuyanlan.com/greatWall/51301.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/greatWall/51302.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/greatWall/51303.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/greatWall/51304.jpg" alt=""></p>
<p>下来之后等了一会其他人，团不好的地方就是有人不守时，晚了半小时返程，12点的时候才出发，本来可以在水立方或者动物园下车，但是在车上听导游说前门有很多吃的，而且杜莎夫人蜡像馆的门票只要60，正常180（后来去问了下蜡像馆工作人员还真是180），不过当时兴趣不大就没买。后来到了前门才知道，就在天安门对面啊啊啊！！！在大前门吃了全聚德，说实话挺腻的，而且环境感觉不好，不知道是不是太有名，开始追求量了，有种快餐店的感觉？上菜很快，但是盘子都是塑料的，emmmm…说不上哪里不好，就是觉得这个品牌不该是这种氛围吧，两个人吃了一只烤鸭（258）一点小菜就开始在前门逛到了5点，前门挺不错，有很多小吃和北京有名的老店。历史风格也保留的很美，逛一下还挺惬意。强力推荐和故宫一起逛，因为之前不知道在一个地方，这个有点折腾了。如果放在和故宫一起还能多去个颐和园之类的地方逛逛~不过也挺值得，反正出来玩嘛最重要的是开心啦。<br><img src="http://qiniu.xuyanlan.com/greatWall/51305.jpg" alt=""></p>
<p>THE END</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间： 5月12日、5月13日 （非高峰期）<br>购票方式：<br>   故宫：网上购门票 + 珍宝馆 + 珠宝馆 78元/人，直接刷身份证进入。<br>   八达岭长城：网上购大门票 + 往返直通车 87元/人</p>
<h4 id="故宫"><a href="#故宫" class="headerlink" title="故宫"></a>故宫</h4><p>特别注意需要提前准备的：<br>    1：下载一个故宫的讲解App（故宫博物馆三毛游）不知道还有没有其他好用的，没有特别去筛选。完了就预先下载好所有的讲解音频文件，这个app解锁所有的讲解需要15元，在到达不同地点会自动播放相应的讲解，还能看见当前的位置，真的是东西南北都分不清的路痴的福音。回来的时候还听到一个妹纸说找不到钟表馆啊，票白买啦！！(<em>^__^</em>) 嘻嘻……，所以下个辅助App还是很方便的。不然得去租故宫的电子讲解器（20元），人比较多，而且走的时候还要还。<br>    2：携带中午的午餐，补充体力<br>    3：充电宝<br></p>]]>
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[algorithms]]></title>
    <link href="http://yoursite.com/2018/05/10/algorithms/"/>
    <id>http://yoursite.com/2018/05/10/algorithms/</id>
    <published>2018-05-09T19:52:39.000Z</published>
    <updated>2019-06-27T08:50:40.266Z</updated>
    <content type="html"><![CDATA[<p>记录算法学习的进度和一些实现代码（Objective-C）<br>开始算法的学习</p>
<h4 id="求p和q的最大公约数"><a href="#求p和q的最大公约数" class="headerlink" title="求p和q的最大公约数"></a>求p和q的最大公约数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//计算两个非负整数p和q的最大公约数，若q是0，则最大公约数为p,否则将p除以q的余数为r，则p和q的最大公约数为q的和r的最大公约数</span><br><span class="line">- (int)maxDivisorP:(int)p q:(int) q &#123;</span><br><span class="line">    if(q == 0) &#123;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    int r = p % q;</span><br><span class="line">    NSLog(@&quot;p is %d, q is %d&quot;,p,q);</span><br><span class="line">    return [self maxDivisorP:q q:r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>牛顿迭代法：<a href="https://www.matongxue.com/madocs/205.html" target="_blank" rel="noopener">通俗易懂的讲解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录算法学习的进度和一些实现代码（Objective-C）<br>开始算法的学习</p>
<h4 id="求p和q的最大公约数"><a href="#求p和q的最大公约数" class="headerlink" title="求p和q的最大公约数"></a>求p和q的最大公]]>
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[五月五-奥森徒步狼人杀]]></title>
    <link href="http://yoursite.com/2018/05/06/%E4%BA%94%E6%9C%88%E4%BA%94-%E5%A5%A5%E6%A3%AE%E5%BE%92%E6%AD%A5%E7%8B%BC%E4%BA%BA%E6%9D%80/"/>
    <id>http://yoursite.com/2018/05/06/五月五-奥森徒步狼人杀/</id>
    <published>2018-05-05T18:52:55.000Z</published>
    <updated>2018-10-31T12:15:00.000Z</updated>
    <content type="html"><![CDATA[<p>时间：2018-05-05<br>地点：北京<br>行程：奥林匹克森林公园 -&gt; 军事博物馆 -&gt; 玉渊潭 -&gt; 北京大学<br>活动类型：休闲、游玩<br>原计划：10位小伙伴8：30在奥森公园地铁站D出口集合，园内稍作徒步然后择一处林荫草地，铺上垫子，放上零食，自我介绍互相认识之后就开始众人期待的狼人杀。<br>突发情况：叮铃铃，叮铃铃…几位小伙伴在出发当天早6点收到处理bug加班电话，无奈工作为先，享乐在后，只能缺席。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>相约8：30在奥森公园集合，由于我是从上海来北京出差，不太熟悉北京的交通，最后集合好的时间到8：50，集合人数：5人，ㄟ( ▔, ▔ )ㄏ 。<br>次日在奥森公园有北马比赛，所以当天就有很多人在预跑，先徒步的计划只能搁置，找了一处草地，铺上垫子，放上零食，各自坐好。<br><a id="more"></a></p>
<h4 id="自我介绍-amp-分享各自难忘的经历"><a href="#自我介绍-amp-分享各自难忘的经历" class="headerlink" title="自我介绍 &amp; 分享各自难忘的经历"></a>自我介绍 &amp; 分享各自难忘的经历</h4><p>沈汉军：热爱生活，热衷户外，本次活动领队<br>kikyouc：百度地图前端的软妹子一枚，比较宅，喜欢旅游，为狼人杀活动所吸引<br>豆珊珊：金融行业的妹子，喜欢旅游<br>Mr.Y：百度的研发小哥<br>水水：来自百度上研，在北京出差，之前就关注度户外，一直想参加度户外的活动<br>各自难忘的经历就不告诉你们，哼╭(╯^╰)╮。</p>
<h4 id="游戏-amp-午餐"><a href="#游戏-amp-午餐" class="headerlink" title="游戏 &amp; 午餐"></a>游戏 &amp; 午餐</h4><p>由于实到人数只有5人，所以狼人杀是不可能了，虽然大家都是因为狼人杀而来。但是人少有人少的玩儿法，emmmm…然后我们玩“逛三园”和“猜词”玩了两个小时，中间下了几次小雨。最后在奥森公园里面稍微走了一会，因为杨浩宇同学另外有约，先行离队，无缘“血战大盘鸡”的美味，哼╭(╯^╰)╮。<br>集合照，拍照的小姐姐带的小朋友很可爱要跟我们一起合影<br><img src="http://qiniu.xuyanlan.com/aoSeng/aosen1.jpg" alt=""><br>下起了小雨，还好带的伞足够，照常愉快的玩耍<br><img src="http://qiniu.xuyanlan.com/aoSeng/aosen3.jpg" alt=""><br>玩累了，出奥森公园觅食啦！<br><img src="http://qiniu.xuyanlan.com/aoSeng/aosen2.jpg" alt=""><br><img src="/2018/05/06/五月五-奥森徒步狼人杀/aosen3.jpg" title="下起了小雨，还好带的伞足够，照常愉快的玩耍"><br><img src="/2018/05/06/五月五-奥森徒步狼人杀/aosen2.jpg" title="玩累了，出奥森公园觅食啦！"><br>血战大盘鸡，血战大盘鸡！！！非常好吃，在北京西站附近哦~<br><img src="http://qiniu.xuyanlan.com/aoSeng/wucan.jpg" alt=""></p>
<h4 id="参观军事博物馆"><a href="#参观军事博物馆" class="headerlink" title="参观军事博物馆"></a>参观军事博物馆</h4><p>午饭后的活动只剩下四个人了，商量了下去了附近的军事博物馆参观，正好大家又都是第一次去，看到了很多抗战时缴获的武器，深感出生在和平年代的幸福。沈汉军同学对此了解的比较多，全程给我们三个妹子解说介绍，棒棒哒！<br>开始参观军事博物馆啦<br><img src="http://qiniu.xuyanlan.com/aoSeng/bowuguan.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/aoSeng/bowuguan1.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/aoSeng/bowuguan2.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/aoSeng/bowuguan3.jpg" alt=""></p>
<h4 id="玉渊潭"><a href="#玉渊潭" class="headerlink" title="玉渊潭"></a>玉渊潭</h4><p>参观完军事博物馆，又去了附近的玉渊潭，毕竟都是妹子，遂坐船游湖，在湖中吹着微风，吃着小零食，聊着八卦，一个小时很快就过去了。<br><img src="http://qiniu.xuyanlan.com/aoSeng/wuyuantan.jpg" alt=""></p>
<h4 id="骑行-amp-晚餐"><a href="#骑行-amp-晚餐" class="headerlink" title="骑行 &amp; 晚餐"></a>骑行 &amp; 晚餐</h4><p>因为我是来北京出差，所以小伙伴都尽量在满足我的要求，中途我还挺想去北京的高校看看，于是决定骑行去北大，途中还穿过人民大学，不过某领队说大概骑行半小时就到，结果足足骑行了一个半小时（领队这个大忽悠！！！），可把妹子们累坏了/(ㄒoㄒ)/~~，但是万万没想到，来到北大门口，正值校庆，需要预约才能进去，没办法，生活总是充满惊喜和无奈，那就只能去大吃一顿啦，哈哈哈~<br><img src="http://qiniu.xuyanlan.com/aoSeng/qiche.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/aoSeng/qiche2.jpg" alt=""><br>晚饭在一个评分很高的牛蛙店（老佛爷），很多人排队，9点才吃上。<br>附上地址：成府路29号国际食尚苑1期3层-6(城铁13号线五道口站A北口出向东100米)<br><img src="/2018/05/06/五月五-奥森徒步狼人杀/wancan.jpg" title="非常美味，强力推荐"><br><img src="http://qiniu.xuyanlan.com/aoSeng/wancan.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/aoSeng/wancan.jpg" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>首都一日游的行程自由而有趣，趁兴而来，尽兴而去，虽没玩成狼人杀，但有新的伙伴，新的故事。<br>附上队友们合力的总结小诗一首：</p>
<p>奥森游戏忙 血战美食香<br>军博中华旺 渡船玉渊潭<br>骑行北京城 清北最抓狂<br>佛系蛙最香 百度户外强</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间：2018-05-05<br>地点：北京<br>行程：奥林匹克森林公园 -&gt; 军事博物馆 -&gt; 玉渊潭 -&gt; 北京大学<br>活动类型：休闲、游玩<br>原计划：10位小伙伴8：30在奥森公园地铁站D出口集合，园内稍作徒步然后择一处林荫草地，铺上垫子，放上零食，自我介绍互相认识之后就开始众人期待的狼人杀。<br>突发情况：叮铃铃，叮铃铃…几位小伙伴在出发当天早6点收到处理bug加班电话，无奈工作为先，享乐在后，只能缺席。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>相约8：30在奥森公园集合，由于我是从上海来北京出差，不太熟悉北京的交通，最后集合好的时间到8：50，集合人数：5人，ㄟ( ▔, ▔ )ㄏ 。<br>次日在奥森公园有北马比赛，所以当天就有很多人在预跑，先徒步的计划只能搁置，找了一处草地，铺上垫子，放上零食，各自坐好。<br></p>]]>
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS小技术点备忘录]]></title>
    <link href="http://yoursite.com/2018/04/12/iOS%E6%8A%80%E6%9C%AF%E7%82%B9%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://yoursite.com/2018/04/12/iOS技术点备忘录/</id>
    <published>2018-04-11T23:52:31.000Z</published>
    <updated>2018-07-02T08:56:51.000Z</updated>
    <content type="html"><![CDATA[<p>记录一些小技术点，方便使用时查找。</p>
<h4 id="更改UITabBar-amp-amp-UINavigationBar背景颜色"><a href="#更改UITabBar-amp-amp-UINavigationBar背景颜色" class="headerlink" title="更改UITabBar &amp;&amp; UINavigationBar背景颜色"></a>更改UITabBar &amp;&amp; UINavigationBar背景颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UITabBar appearance] setBarTintColor:[UIColor redColor]];</span><br><span class="line">[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure>
<h4 id="更改UITabBar-amp-amp-UINavigationBar字体颜色"><a href="#更改UITabBar-amp-amp-UINavigationBar字体颜色" class="headerlink" title="更改UITabBar &amp;&amp; UINavigationBar字体颜色"></a>更改UITabBar &amp;&amp; UINavigationBar字体颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//改变按钮navigationBar tintColor颜色</span><br><span class="line">self.navigationController.navigationBar.tintColor = [UIColor colorWithRed:102/255.0 green:102/255.0 blue:102/255.0 alpha:1.0];</span><br><span class="line">//改变tabbar 正常颜色，选中色</span><br><span class="line"> NSDictionary *attributeNormal = @&#123;NSForegroundColorAttributeName:[UIColor grayColor]&#125;;</span><br><span class="line">[subVC.tabBarItem setTitleTextAttributes:attributeNormal forState:(UIControlStateNormal)];</span><br><span class="line"> NSDictionary *attributeSelected = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;;</span><br><span class="line">[subVC.tabBarItem setTitleTextAttributes:attributeSelected forState: (UIControlStateSelected)];</span><br></pre></td></tr></table></figure>
<h4 id="设置UIViewController的view的top在navigationBar下面-amp-bottom位置在Tabbar的上面"><a href="#设置UIViewController的view的top在navigationBar下面-amp-bottom位置在Tabbar的上面" class="headerlink" title="设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面"></a>设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tabBarController.tabBar.translucent = NO;</span><br><span class="line">uiviewController.navigationController.navigationBar.translucent = NO;</span><br></pre></td></tr></table></figure>
<h4 id="改变UISlider的进度条高度"><a href="#改变UISlider的进度条高度" class="headerlink" title="改变UISlider的进度条高度"></a>改变UISlider的进度条高度</h4><p>需要继承UISlider并t重载trackRectForBounds方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGRect)trackRectForBounds:(CGRect)bounds</span><br><span class="line">&#123;</span><br><span class="line">    return CGRectMake(0, 0, CGRectGetWidth(self.frame), 5.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="UIPageViewController-翻页效果"><a href="#UIPageViewController-翻页效果" class="headerlink" title="UIPageViewController 翻页效果"></a>UIPageViewController 翻页效果</h4><p>UIPageViewController的默认翻页效果类似于翻书的效果，如果想要平铺翻页和指定翻页方向呢？我们发现有navigationOrientation和transitionStyle两个属性，但是这两个属性是只读的，查看.h文件可知UIPageViewController提供了init方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(nullable NSDictionary&lt;NSString *, id&gt; *)options NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure><br>所以需要改变默认的翻页效果和方向可以通过init方法实现；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *options = @&#123;UIPageViewControllerOptionInterPageSpacingKey : @(0)&#125;;</span><br><span class="line">   _pageViewController = [[UIPageViewController alloc] initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll</span><br><span class="line">                                                         navigationOrientation:UIPageViewControllerNavigationOrientationHorizontal</span><br><span class="line">                                                                       options:options];</span><br></pre></td></tr></table></figure></p>
<h4 id="push新页面时隐藏tabbar"><a href="#push新页面时隐藏tabbar" class="headerlink" title="push新页面时隐藏tabbar"></a>push新页面时隐藏tabbar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIViewController *viewController = [[UIViewController alloc] init];</span><br><span class="line">[viewController setHidesBottomBarWhenPushed:YES];//一定要在push之前调用</span><br><span class="line">[self.navigationController pushViewController:viewController animated:YES];</span><br></pre></td></tr></table></figure>
<h4 id="Xcode-Build-Settings-Reference-pods配置时使用的key对照表"><a href="#Xcode-Build-Settings-Reference-pods配置时使用的key对照表" class="headerlink" title="Xcode Build Settings Reference , pods配置时使用的key对照表"></a>Xcode Build Settings Reference , pods配置时使用的key对照表</h4><p><a href="https://pewpewthespells.com/blog/buildsettings.html" target="_blank" rel="noopener">https://pewpewthespells.com/blog/buildsettings.html</a></p>
<h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)telePhoneMatchRules &#123; //11位数字</span><br><span class="line">    BOOL match = NO;</span><br><span class="line">    NSString *telePhone = _telephoneField.text;</span><br><span class="line">    if (telePhone.length &gt; 0)&#123;</span><br><span class="line">        NSString *regex = @&quot;^\\d&#123;11&#125;$&quot;;</span><br><span class="line">        NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex];</span><br><span class="line">        match = [pred evaluateWithObject:telePhone];</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多正则参考：<a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html" target="_blank" rel="noopener">http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p>
<h4 id="push到下级页面之前，无感知的移除某几个上级页面"><a href="#push到下级页面之前，无感知的移除某几个上级页面" class="headerlink" title="push到下级页面之前，无感知的移除某几个上级页面"></a>push到下级页面之前，无感知的移除某几个上级页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[self.navigationController pushViewController:nextVC animated:YES];</span><br><span class="line">NSMutableArray *controllers = [NSMutableArray array];</span><br><span class="line">            //移除前面的几个vc</span><br><span class="line">            for(UIViewController *viewController in self.navigationController.viewControllers)&#123;</span><br><span class="line">                if(![viewController isKindOfClass:[UIViewController1 class]] &amp;&amp;</span><br><span class="line">                   ![viewController isKindOfClass:[UIViewController2 class]] &amp;&amp;</span><br><span class="line">                   ![viewController isKindOfClass:[UIViewController3 class]])&#123;</span><br><span class="line">                    [controllers addObject:viewController];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            [self.navigationController setViewControllers:[controllers copy]];</span><br></pre></td></tr></table></figure>
<h4 id="自定义UITableViewCell多选模式下选中和未选中的图片"><a href="#自定义UITableViewCell多选模式下选中和未选中的图片" class="headerlink" title="自定义UITableViewCell多选模式下选中和未选中的图片"></a>自定义UITableViewCell多选模式下选中和未选中的图片</h4><p>在cell中实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    for (UIControl *control in self.subviews) &#123;</span><br><span class="line">        if ([control isMemberOfClass:NSClassFromString(@&quot;UITableViewCellEditControl&quot;)]) &#123;</span><br><span class="line">            for(UIView *view in control.subviews) &#123;</span><br><span class="line">              //找到选中时的image</span><br><span class="line">                if ([view isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">                    UIImageView *imageView = (UIImageView *)view;</span><br><span class="line">                    imageView.contentMode = UIViewContentModeScaleToFill;</span><br><span class="line">                    if(self.selected) &#123;</span><br><span class="line">                        imageView.image = [UIImage imageNamed:@&quot;ac_selectedImage&quot;];</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        imageView.image = [UIImage imageNamed:@&quot;ac_disSelectedImage&quot;];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="判断今天、明天、后天"><a href="#判断今天、明天、后天" class="headerlink" title="判断今天、明天、后天"></a>判断今天、明天、后天</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval sencondDay = 24 * 60 * 60;</span><br><span class="line">NSDate *today = [NSDate date];</span><br><span class="line">NSDate *tomorrow = [today dateByAddingTimeInterval:sencondDay];</span><br><span class="line">NSDate *postnatal = [today dateByAddingTimeInterval:sencondDay * 2];</span><br><span class="line">// 10 first characters of description is the calendar date:</span><br><span class="line">NSString *todayString = [[today description] substringToIndex:10];</span><br><span class="line">NSString *tomorrowString = [[tomorrow description] substringToIndex:10];</span><br><span class="line">NSString *postnatalString = [[postnatal description] substringToIndex:10];</span><br><span class="line">NSString *dateString = [[date description] substringToIndex:10];</span><br><span class="line">if ([todayString isEqualToString:dateString]) &#123;</span><br><span class="line">    repeatDetail = @&quot;今天   仅一次&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else if ([tomorrowString isEqualToString:dateString]) &#123;</span><br><span class="line">    repeatDetail = @&quot;明天   仅一次&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else if ([postnatalString isEqualToString:dateString]) &#123;</span><br><span class="line">    repeatDetail = @&quot;后天   仅一次&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="隐藏导航条和显示导航条的页面间返回手势平滑切换"><a href="#隐藏导航条和显示导航条的页面间返回手势平滑切换" class="headerlink" title="隐藏导航条和显示导航条的页面间返回手势平滑切换"></a>隐藏导航条和显示导航条的页面间返回手势平滑切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    //重点方法</span><br><span class="line">    [self.navigationController setNavigationBarHidden:YES animated:YES]; </span><br><span class="line">    //[self.navigationController setNavigationBarHidden:NO animated:YES]; //从不显示的页面返回显示页面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是使用开源库：FDFullscreenPopGesture</p>
<h4 id="改变UITableViewCell复选框默认图"><a href="#改变UITableViewCell复选框默认图" class="headerlink" title="改变UITableViewCell复选框默认图"></a>改变UITableViewCell复选框默认图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    for (UIControl *control in self.subviews) &#123;</span><br><span class="line">        if ([control isMemberOfClass:NSClassFromString(@&quot;UITableViewCellEditControl&quot;)]) &#123;</span><br><span class="line">            for(UIView *view in control.subviews) &#123;</span><br><span class="line">              //找到选中时的image</span><br><span class="line">                if ([view isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">                    UIImageView *imageView = (UIImageView *)view;</span><br><span class="line">                    imageView.contentMode = UIViewContentModeScaleToFill;</span><br><span class="line">                    if(self.selected) &#123;</span><br><span class="line">                        imageView.image = [UIImage imageNamed:@&quot;ac_selectedImage&quot;];</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        imageView.image = [UIImage imageNamed:@&quot;ac_disSelectedImage&quot;];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是会偶现某些cell还是出现默认复选框的情况，应该是重用时没有触发layoutSubviews导致，所以并不是很好</p>
<h4 id="设备信息，app信息"><a href="#设备信息，app信息" class="headerlink" title="设备信息，app信息"></a>设备信息，app信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  </span><br><span class="line">// app名称  </span><br><span class="line"> NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  </span><br><span class="line">// app版本  </span><br><span class="line"> NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  </span><br><span class="line">// app build版本  </span><br><span class="line">NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  </span><br><span class="line">  </span><br><span class="line">//手机序列号  </span><br><span class="line">NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  </span><br><span class="line">NSLog(@&quot;手机序列号: %@&quot;,identifierNumber);  </span><br><span class="line">//手机别名： 用户定义的名称  </span><br><span class="line">NSString* userPhoneName = [[UIDevice currentDevice] name];  </span><br><span class="line">NSLog(@&quot;手机别名: %@&quot;, userPhoneName);  </span><br><span class="line">//设备名称  </span><br><span class="line">NSString* deviceName = [[UIDevice currentDevice] systemName];  </span><br><span class="line">NSLog(@&quot;设备名称: %@&quot;,deviceName );  </span><br><span class="line">//手机系统版本  </span><br><span class="line">NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  </span><br><span class="line">NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion);  </span><br><span class="line">//手机型号  </span><br><span class="line">NSString* phoneModel = [[UIDevice currentDevice] model];  </span><br><span class="line">NSLog(@&quot;手机型号: %@&quot;,phoneModel );  </span><br><span class="line">//地方型号  （国际化区域名称）  </span><br><span class="line">NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  </span><br><span class="line">NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel );  </span><br><span class="line">  </span><br><span class="line">NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  </span><br><span class="line">// 当前应用名称  </span><br><span class="line">NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  </span><br><span class="line">NSLog(@&quot;当前应用名称：%@&quot;,appCurName);  </span><br><span class="line">// 当前应用软件版本  比如：1.0.1  </span><br><span class="line">NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  </span><br><span class="line">NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion);  </span><br><span class="line">// 当前应用版本号码   int类型  </span><br><span class="line">NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  </span><br><span class="line">NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum); </span><br></pre></td></tr></table></figure>
<h4 id="手机震动一下"><a href="#手机震动一下" class="headerlink" title="手机震动一下"></a>手机震动一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AudioToolbox/AudioToolbox.h&gt;</span><br><span class="line">AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);</span><br></pre></td></tr></table></figure>
<h4 id="顶部导航条电量信息变色"><a href="#顶部导航条电量信息变色" class="headerlink" title="顶部导航条电量信息变色"></a>顶部导航条电量信息变色</h4><p>重写preferredStatusBarStyle方法，比如变成白色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle &#123;</span><br><span class="line">    return UIStatusBarStyleLightContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="设置TextField属性之文字距左边框的距离"><a href="#设置TextField属性之文字距左边框的距离" class="headerlink" title="设置TextField属性之文字距左边框的距离"></a>设置TextField属性之文字距左边框的距离</h4><p>textfield有个属性leftview,设置一个只有宽度的leftView.然后需要将leftViewMode设置为UITextFieldViewModeAlways.因为默认textfield.leftView是不显示的.</p>
<h4 id="iOS中调整view层级位置的两个属性"><a href="#iOS中调整view层级位置的两个属性" class="headerlink" title="iOS中调整view层级位置的两个属性"></a>iOS中调整view层级位置的两个属性</h4><p>控件的层级关系和你加入到父视图的顺序有关，也就是先addsubview至父视图的，层级越低，会被后加入的遮盖。<br>可以通过以下函数改变子视图的层级<br>将一个UIView显示在调用者view最前面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)bringSubviewToFront:(UIView *)view;</span><br></pre></td></tr></table></figure><br>将视图显示在下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendSubviewToBack:(UIView *)view;</span><br></pre></td></tr></table></figure></p>
<h4 id="改变状态栏背景色导致返回手势过程（从有导航条-gt-隐藏导航条）中，导航条突然消失问题"><a href="#改变状态栏背景色导致返回手势过程（从有导航条-gt-隐藏导航条）中，导航条突然消失问题" class="headerlink" title="改变状态栏背景色导致返回手势过程（从有导航条-&gt;隐藏导航条）中，导航条突然消失问题"></a>改变状态栏背景色导致返回手势过程（从有导航条-&gt;隐藏导航条）中，导航条突然消失问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//重写 UINavigationController 得方法</span><br><span class="line">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class="line">　　return  self.visibleViewController;</span><br><span class="line">&#125;</span><br><span class="line">- (UIViewController *)childViewControllerForStatusBarHidden&#123;</span><br><span class="line">　　return self.visibleViewController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打包突然出现errSecInternalComponent-Command-usr-bin-codesign-failed-with-exit-code-1错误"><a href="#打包突然出现errSecInternalComponent-Command-usr-bin-codesign-failed-with-exit-code-1错误" class="headerlink" title="打包突然出现errSecInternalComponent Command /usr/bin/codesign failed with exit code 1错误"></a>打包突然出现errSecInternalComponent Command /usr/bin/codesign failed with exit code 1错误</h4><p>Xcode bug，可能是过期证书过多，清理过期证书，或者重启mac！！！</p>
<h4 id="UIPickerView-中间黑线消失的问题"><a href="#UIPickerView-中间黑线消失的问题" class="headerlink" title="UIPickerView 中间黑线消失的问题"></a>UIPickerView 中间黑线消失的问题</h4><p>问题描述：使用UIPickerView过程中发现在某种情况下pickview的两条默认的黑线消失了！！！<br>测试发现在viewDidLoad中add到view上的pickview的线又会显示！！！<br>查找问题：查找发现黑色线的设置是通过-[UIPickerView _setMagnifierLineColor:]方法设置的，不显示黑线是因为在-[UIPickerView _setMagnifierLineColor:]这个方法调用得时候pickview的subviews为nil，自然给线的view设置颜色无效。但是为什么在viewDidLoad中add到view上的pickview的线会显示呢？断点发现在这种情况下-[UIPickerView _setMagnifierLineColor:]会被调用两次，第一次调用时pickview的subviews依然为nil，第二次subviews中则包含了两根线的view。<br><img src="/2018/04/12/iOS技术点备忘录/lineview.jpg" title="第二次调用的堆栈信息图"><br>猜想：苹果的bug，设置颜色的方法不应该在subviews还没准备好的时候去调用。<br>暂时的解决办法：在pickview被添加到父view的时候调用layoutSubviews方法，让其subviews先绘制出来;<br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一些小技术点，方便使用时查找。</p>
<h4 id="更改UITabBar-amp-amp-UINavigationBar背景颜色"><a href="#更改UITabBar-amp-amp-UINavigationBar背景颜色" class="headerlink" title="更改UITabBar &amp;&amp; UINavigationBar背景颜色"></a>更改UITabBar &amp;&amp; UINavigationBar背景颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[UITabBar appearance] setBarTintColor:[UIColor redColor]];</span><br><span class="line">[[UINavigationBar appearance] setBarTintColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure>
<h4 id="更改UITabBar-amp-amp-UINavigationBar字体颜色"><a href="#更改UITabBar-amp-amp-UINavigationBar字体颜色" class="headerlink" title="更改UITabBar &amp;&amp; UINavigationBar字体颜色"></a>更改UITabBar &amp;&amp; UINavigationBar字体颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//改变按钮navigationBar tintColor颜色</span><br><span class="line">self.navigationController.navigationBar.tintColor = [UIColor colorWithRed:102/255.0 green:102/255.0 blue:102/255.0 alpha:1.0];</span><br><span class="line">//改变tabbar 正常颜色，选中色</span><br><span class="line"> NSDictionary *attributeNormal = @&#123;NSForegroundColorAttributeName:[UIColor grayColor]&#125;;</span><br><span class="line">[subVC.tabBarItem setTitleTextAttributes:attributeNormal forState:(UIControlStateNormal)];</span><br><span class="line"> NSDictionary *attributeSelected = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;;</span><br><span class="line">[subVC.tabBarItem setTitleTextAttributes:attributeSelected forState: (UIControlStateSelected)];</span><br></pre></td></tr></table></figure>
<h4 id="设置UIViewController的view的top在navigationBar下面-amp-bottom位置在Tabbar的上面"><a href="#设置UIViewController的view的top在navigationBar下面-amp-bottom位置在Tabbar的上面" class="headerlink" title="设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面"></a>设置UIViewController的view的top在navigationBar下面 &amp; bottom位置在Tabbar的上面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tabBarController.tabBar.translucent = NO;</span><br><span class="line">uiviewController.navigationController.navigationBar.translucent = NO;</span><br></pre></td></tr></table></figure>
<h4 id="改变UISlider的进度条高度"><a href="#改变UISlider的进度条高度" class="headerlink" title="改变UISlider的进度条高度"></a>改变UISlider的进度条高度</h4><p>需要继承UISlider并t重载trackRectForBounds方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGRect)trackRectForBounds:(CGRect)bounds</span><br><span class="line">&#123;</span><br><span class="line">    return CGRectMake(0, 0, CGRectGetWidth(self.frame), 5.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="备忘录" scheme="http://yoursite.com/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[远征腾格里沙漠-五湖连穿]]></title>
    <link href="http://yoursite.com/2018/04/10/%E8%BF%9C%E5%BE%81%E8%85%BE%E6%A0%BC%E9%87%8C/"/>
    <id>http://yoursite.com/2018/04/10/远征腾格里/</id>
    <published>2018-04-10T13:07:25.000Z</published>
    <updated>2018-10-31T11:43:29.000Z</updated>
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>日期：2018-04-05 ~ 2018-04-07<br>行程特色：领略塞外沙漠风光，体验沙漠徒步，挑战自我<br>全程：53公里<br>装备：防沙鞋、防晒帽、墨镜、轻装<br>温度：-4°C ~ 25°C<br>行程安排：4号飞银川，5号进沙漠，7号出沙漠，8号从银川飞回上海。</p>
<p><img src="http://qiniu.xuyanlan.com/tengGeLi/host.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/home.jpg" alt=""></p>
<a id="more"></a>
<h4 id="4-4号下午抵达银川"><a href="#4-4号下午抵达银川" class="headerlink" title="4-4号下午抵达银川"></a>4-4号下午抵达银川</h4><p>下午到达银川风沙特别大，但是还是冒着风沙去了影视城游玩了一圈，因为风沙特别大，里面的很多商店和游戏项目都关门了.空气中都是风沙的味道。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/441.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/442.jpg" alt=""></p>
<h4 id="4-5-沙漠徒步启程-amp-天鹅湖"><a href="#4-5-沙漠徒步启程-amp-天鹅湖" class="headerlink" title="4-5 沙漠徒步启程 &amp; 天鹅湖"></a>4-5 沙漠徒步启程 &amp; 天鹅湖</h4><p>踏上沙漠的那一刻，脚随之陷入柔软的沙子，前进的步伐却很沉重，刚开始走的十几步感觉非常的累，慢慢坚持就习惯了，走着走着就进入了一个无敌状态了，感觉可以一步一步，一直走下去，没有想象中的困难。第一天走沙漠，阳沙天气，气温10°C左右，风很大，吹的脸生疼，一定得带头巾、帽子、墨镜还有手套，从午开始走，走到下午5点半到天鹅湖营地。开始搭帐篷，帐篷是俱乐部的人开车带进来的，徒步时只需要要轻装上阵就好。不过也有些徒步俱乐部是全程重装的，自己带着帐篷和实物和水，这个就需要非常专业的徒步经验和体力了。到了晚上的风沙愈发的大了，帐篷各种乱飞，没办法，后来大部分人领着睡袋宿在了吃饭的大充气帐篷里，四五十个平方的地上睡满了一地的人，听着呼呼的风声。恶劣的环境，寒冷的风，让有些小伙伴对后两天的行程充满抗拒，深夜包车去舒适的下一个营地了。风太大了都没办法拍什么照片，附上两张图吧。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/452.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/453.jpg" alt=""></p>
<h4 id="4-6-一整天的沙漠徒步-—-行程28公里"><a href="#4-6-一整天的沙漠徒步-—-行程28公里" class="headerlink" title="4-6 一整天的沙漠徒步 — 行程28公里"></a>4-6 一整天的沙漠徒步 — 行程28公里</h4><p>第二天的沙漠徒步比较累，要一直走整整一天，同样也是轻装，只带少量的路餐和水，水中途还会有补给。这一天天气晴朗，但是依然比较冷，均温度10°左右，防晒和防风还是得做好。出发之前没有注意，带了一双透气的鞋子，沙子哗啦啦的往鞋子里面流~/(ㄒoㄒ)/~~，还好沙漠的沙子非常柔软细腻，入鞋并不会磨脚，但是沙子多了总是不舒服，只能用保鲜袋套好鞋子，再用头巾把鞋子扎起来，不过这样就非常的捂，等结束行程鞋子都湿透了。上午的行程是比较累的，一直是爬沙丘的状态。值得欣慰的是，我们坚持下来了。默默的表扬某个小胖子💕^_^。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/461.jpg" alt=""><br>五湖连穿之–乌兰湖（中午休息就餐点）<br><img src="http://qiniu.xuyanlan.com/tengGeLi/467.jpg" alt=""><br>从乌兰湖到苏海图这段路是这三天中最最好走的路了，一路上基本上都是盐碱地，有种终于脚踏实地的感觉。乌兰湖到苏海图中间的盐碱地，30-50分钟穿过<br><img src="http://qiniu.xuyanlan.com/tengGeLi/466.jpg" alt=""><br>苏海图，苏海图湖现在是一片一片的小湖泊组成，我们从苏海图的盐碱地中通行。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/468.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/469.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/4610.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/4611.jpg" alt=""><br>走到了一条废弃的高速公路，真是非常亲切啊，而且已经可以看到今晚驻扎的营地了，相当开心<br><img src="http://qiniu.xuyanlan.com/tengGeLi/464.jpg" alt=""></p>
<p>大概5点半左右走到第二天的营地，太阳湖。坚持了一天，停下来之后腿酸到不会正常走路了！<br>体验了下领队给我们的红酒晚宴和篝火晚会，有几个妹子跳的舞还挺专业，哈哈~<br>夜晚的星空真的是太美了，可惜不敢拿出单反来拍，怕进沙子。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/462.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/463.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/465.jpg" alt=""></p>
<h4 id="4-7-体验沙漠之美"><a href="#4-7-体验沙漠之美" class="headerlink" title="4-7 体验沙漠之美"></a>4-7 体验沙漠之美</h4><p>第三天从包裹在冰霜下的帐篷中醒来，天气大好，经历过狂风、沙尘暴，沙漠终于要用美景和好天气陪伴我们最后的半日行程，真正的体验到沙漠的美丽。<br>太阳湖真的是太美了，清澈的湖水中沙漠的倒影。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/471.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/472.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/473.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/475.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/474.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/478.jpg" alt=""></p>
<p>沙漠徒步特有的风景线，仔细看还能看见我们前进的方向悬挂着月亮。<br><img src="http://qiniu.xuyanlan.com/tengGeLi/476.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/477.jpg" alt=""></p>
<h4 id="沙漠遇见的小伙伴"><a href="#沙漠遇见的小伙伴" class="headerlink" title="沙漠遇见的小伙伴"></a>沙漠遇见的小伙伴</h4><p><img src="http://qiniu.xuyanlan.com/tengGeLi/1.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/2.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/6.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/5.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/3.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/4.jpg" alt=""></p>
<h4 id="携手徒步沙漠的小伙伴们"><a href="#携手徒步沙漠的小伙伴们" class="headerlink" title="携手徒步沙漠的小伙伴们"></a>携手徒步沙漠的小伙伴们</h4><p><img src="http://qiniu.xuyanlan.com/tengGeLi/collect1.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/collect2.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/collect3.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/collect4.jpg" alt=""></p>
<h4 id="随行的队医，贴心守护"><a href="#随行的队医，贴心守护" class="headerlink" title="随行的队医，贴心守护"></a>随行的队医，贴心守护</h4><p><img src="http://qiniu.xuyanlan.com/tengGeLi/collect5.jpg" alt=""></p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>每次长时间徒步内心都经过了想放弃-&gt;下次再也不徒步了-&gt;渐入佳境-&gt;完成之后的内心满足+身心俱疲，但是下次有好的路线还是义无反顾的收拾行囊出发。<br>喜欢上了用脚步领略不同路线的风景，不同的挑战，有相同的人陪伴吧。工作之后的好几年都比较宅，不喜欢出门逛街，购物。但突然发现自己还是挺喜欢户外的，就一发不可收拾，感觉把身心带到了一个自己很喜欢的健康状态，这才是最可贵的。诗和远方喜欢就出发了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>日期：2018-04-05 ~ 2018-04-07<br>行程特色：领略塞外沙漠风光，体验沙漠徒步，挑战自我<br>全程：53公里<br>装备：防沙鞋、防晒帽、墨镜、轻装<br>温度：-4°C ~ 25°C<br>行程安排：4号飞银川，5号进沙漠，7号出沙漠，8号从银川飞回上海。</p>
<p><img src="http://qiniu.xuyanlan.com/tengGeLi/host.jpg" alt=""><br><img src="http://qiniu.xuyanlan.com/tengGeLi/home.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Twitter Crashlytics-iOS]]></title>
    <link href="http://yoursite.com/2018/02/08/Twitter-Crashlytics-iOS/"/>
    <id>http://yoursite.com/2018/02/08/Twitter-Crashlytics-iOS/</id>
    <published>2018-02-07T17:29:17.000Z</published>
    <updated>2018-10-31T11:59:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>Twitter的Crashlytics SDK接口做的非常简洁，后台也是非常友好，关于如何使用，在这里贴下别的同学的链接，不再赘述啦！<br><a href="https://www.jianshu.com/p/0a2ff9cd5c23" target="_blank" rel="noopener">iOS 崩溃统计工具-Crashlytics</a><br>了解crash收集：<a href="https://nianxi.net/ios/ios-crash-reporter.html" target="_blank" rel="noopener">漫谈iOS Crash收集框架</a></p>
<h3 id="customKey-和-customLog"><a href="#customKey-和-customLog" class="headerlink" title="customKey 和 customLog"></a>customKey 和 customLog</h3><p>customKey 和 customLog非常有用，可以跟随crash的report一起上传到服务器上，可以记录从启动到崩溃过程中的用户行为路径，方便用户定位crash根源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//customKey</span><br><span class="line">[CrashlyticsKit setUserIdentifier:@&quot;device&quot;];</span><br><span class="line">[CrashlyticsKit setUserEmail:@&quot;133@qq.com&quot;];</span><br><span class="line">[CrashlyticsKit setUserName:@&quot;xyl&quot;];</span><br><span class="line">[CrashlyticsKit setObjectValue:@&quot;testValue&quot; forKey:@&quot;testKey&quot;];</span><br><span class="line">NSDictionary *dict = @&#123;</span><br><span class="line">                       @&quot;key1&quot;:@&quot;key1&quot;,</span><br><span class="line">                       @&quot;key2&quot;:@&quot;key2&quot;</span><br><span class="line">                       &#125;;</span><br><span class="line">[CrashlyticsKit setObjectValue:dict forKey:@&quot;testKeyDict&quot;];</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.xuyanlan.com/Twitter-Crashlytics-iOS/customKey.png" alt=""><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//customLog</span><br><span class="line">CLS_LOG(@&quot; testCrashButton3Tapped log1&quot;);</span><br><span class="line">CLS_LOG(@&quot; UncaughtExceptionHandler test&quot;);</span><br><span class="line">//.... more</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.xuyanlan.com/Twitter-Crashlytics-iOS/customLog.png" alt=""></p>
<h3 id="和NSSetUncaughtExceptionHandler-amp-UncaughtExceptionHandler-不冲突"><a href="#和NSSetUncaughtExceptionHandler-amp-UncaughtExceptionHandler-不冲突" class="headerlink" title="和NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler)不冲突"></a>和NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler)不冲突</h3><p>在监听中使用customKey和customLog添加一些自己想放到崩溃信息中的重要信息，比如当前显示的view之类的。</p>
<h3 id="Unix信号捕获和crashlytics冲突问题"><a href="#Unix信号捕获和crashlytics冲突问题" class="headerlink" title="Unix信号捕获和crashlytics冲突问题"></a>Unix信号捕获和crashlytics冲突问题</h3><p>如上如果我想在Mach异常崩溃的时候添加一些log信息，这个时候会有些问题了，如signal(SIGABRT, signalHandler)的捕获，在crashlytics前设置会被crashlytics覆盖导致signalHandler不被调用，在crashlytics后调用会导致crashlytics捕获unix信号的handler不被调用，这都不是我们想看到的，解决办法是想办法保存crashlytics的signalHandler，在crashlytics初始化后调用。解决办法请参考<a href="https://www.jianshu.com/p/29051908c74b" target="_blank" rel="noopener">iOS Crash 捕获及堆栈符号化思路剖析</a>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//提供一个SIGABRT类型的异常</span><br><span class="line">typedef struct Test</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;Test;</span><br><span class="line">Test *pTest = &#123;1,2&#125;;</span><br><span class="line">free(pTest);//导致SIGABRT的错误，因为内存中根本就没有这个空间，哪来的free，就在栈中的对象而已</span><br><span class="line">pTest-&gt;a = 5;</span><br></pre></td></tr></table></figure></p>
<h3 id="crashlytics的崩溃信息收集、上传流程图"><a href="#crashlytics的崩溃信息收集、上传流程图" class="headerlink" title="crashlytics的崩溃信息收集、上传流程图"></a>crashlytics的崩溃信息收集、上传流程图</h3><p><img src="http://qiniu.xuyanlan.com/Twitter-Crashlytics-iOS/preview.png" alt=""></p>
<p><a href="https://mermaidjs.github.io/mermaid-live-editor/#/view/c2VxdWVuY2VEaWFncmFtCiAgcGFydGljaXBhbnQgQ3Jhc2hseXRpY3MKICBwYXJ0aWNpcGFudCBQcm9jZXNzaW5nCiAgcGFydGljaXBhbnQgU2Vzc2lvbklECiAgcGFydGljaXBhbnQgdXBsb2FkCiAgcGFydGljaXBhbnQgRW50ZXJCYWNrZ3JvdW5kCiAgcGFydGljaXBhbnQgRW50ZXJGb3JlZ3JvdW5kCiAgcGFydGljaXBhbnQgRXhjZXB0aW9uQ3Jhc2gKICBwYXJ0aWNpcGFudCBTaWduYWxDcmFzaAoKCiAgQ3Jhc2hseXRpY3MtLT4-Q3Jhc2hseXRpY3M6IHN0YXJ0IQoKICBDcmFzaGx5dGljcy0tPlNlc3Npb25JRDogbmV3CiAgTm90ZSBvdmVyIFNlc3Npb25JRDrpmo_mnLrnlJ_miJDkuIDkuKoIc2Vzc2lvbl9pZAogIFNlc3Npb25JRC0tPkNyYXNobHl0aWNzOiBiYWNrIHNlc3Npb25JRAogICBOb3RlIG92ZXIgQ3Jhc2hseXRpY3M6c3RlcDI65LiL6Z2i6K-055qE5paH5Lu26YO95piv5ZyoL0xpYnJhcnkvQ2FjaGVzL2NvbS5jcmFzaGx5dGljcy5kYXRhLwh7YnVuZGxlSUR9L-S4iwogICBOb3RlIG92ZXIgQ3Jhc2hseXRpY3M6c3RlcDI65ZyoVjMvYWN0aXZl5paH5Lu25aS55LiL5paw5bu65LiA5LiqCOS7peivpUlE5Li6bmFtZeeahOaWh-S7tuWkue-8jOeUn-aIkOm7mOiupOaWh-S7tuWIsOaWh-S7tuWkueS4iwogIENyYXNobHl0aWNzLS0-PkNyYXNobHl0aWNzOiByZWFkCiAgTm90ZSBvdmVyIENyYXNobHl0aWNzOnN0ZXAxOumBjeWOhuivu-WPllYzL2FjdGl2ZeaWh-S7tuWkueS4i-eahOaWh-S7tuWkue-8iOmZpOS6huS7peS4iuaPkOWIsOeahOWImm5ld-eahOaWh-S7tuWkue-8ie-8jOWIpOaWreivpeaWh-S7tuWkueS4i-aYr-WQpuaciWV4Y2VwdGlvbi5jbHNyZWNvcmTmlofku7bmiJbogIVzaWduYWwuY2xzcmVjb3Jk5paH5Lu2CiAgYWx0IOaciWV4Y2VwdGlvbi5jbHNyZWNvcmTmlofku7YKICBOb3RlIG92ZXIgQ3Jhc2hseXRpY3M65Y-R6YCBY3Jhc2hseXRpY3NEaWREZXRlY3RSZXBvcnRGb3JMYXN0RXhlY3V0aW9uOmNvbXBsZXRpb25IYW5kbGVyIGRlbGVnYXRlCiAgQ3Jhc2hseXRpY3MtLT4-UHJvY2Vzc2luZzrmlofku7blpITnkIZwcm9jZXNzaW5nCiAgIE5vdGUgb3ZlciBQcm9jZXNzaW5nOnYzL3Byb2Nlc3NpbmfkuIvnlJ_miJDkuIDkuKpyZXBvcnRfaWTmlofku7blpLks5aSN5Yi25omA5pyJ5paH5Lu25YiwdjMvcHJvY2Vzc2luZ-S4i-W5tueUn-aIkOS4gOS4qmV4Y2VwdGlvbi5jbHNyZWNvcmQuc3ltYm9saWNhdGVk5paH5Lu277yM54S25ZCO5Yig6Zmkc2Vzc2lvbl9pZOaWh-S7tuWkuQogIE5vdGUgb3ZlciBQcm9jZXNzaW5nOiAI5omT5YyFZXhjZXB0aW9u5paH5Lu25ZKMbG9n5paH5Lu2562J77yM55Sf5oiQ5om56YeP5LiK5Lyg5paH5Lu255qE5LiA5p2hcG9zdOS_oeaBr-aWh-S7tuWIsAh2My9wcmVwYXJlZOaWh-S7tuWkueS4i--8jOeEtuWQjuWIoOmZpOivpeaWh-S7tuWkuQogIGVsc2Ug5rKh5pyJ5pyJZXhjZXB0aW9uLmNsc3JlY29yZOaWh-S7tgogIE5vdGUgb3ZlciBDcmFzaGx5dGljczrliKDpmaTor6Xmlofku7blpLkKICBlbmQKCiAgTm90ZSBvdmVyIENyYXNobHl0aWNzOmFuYWx5dGljcy92Mi9jcmFzaF9tZXRhZGF0YeabtOaWsAogIE5vdGUgb3ZlciBDcmFzaGx5dGljczrlj5HpgIFjcmFzaGx5dGljc0RpZERldGVjdFJlcG9ydEZvckxhc3RFeGVjdXRpb24gZGVsZWdhdCAKCiAgTm90ZSBvdmVyIENyYXNobHl0aWNzOnVwbG9hZCByZXBvcnQKICBDcmFzaGx5dGljcy0-PnVwbG9hZDogc3RhcnQgdXBsb2FkCiAgTm90ZSBvdmVyIHVwbG9hZDog6YGN5Y6GdjMvcHJlcGFyZWTmlofku7blpLnkuIvnmoRwb3N05L-h5oGv5paH5Lu277yM5L6d5qyh5LiK5LygCiAgYWx0IHVwbG9hZCAIc3VjYyAKICBOb3RlIG92ZXIgdXBsb2FkOiDliKDpmaRWMy9wcmVwYXJlZOaWh-S7tuWkueS4i-W3sue7j-S4iuS8oOaIkOWKn-eahHJlcG9ydOaWh-S7tuWkuQogIGVsc2UgdXBsb2FkIGZhaWwKICBOb3RlIG92ZXIgdXBsb2FkOuS4jeWIoOmZpHBvc3Tkv6Hmga_mlofku7bvvIzph43or5XkuIrkvKAKICBlbmQKCgogIE5vdGUgb3ZlciBFbnRlckJhY2tncm91bmQ6YW5hbHl0aWNzL3YyL2V2ZW50IOaWh-S7tuWkueS4i-S8mueUn-aIkC5sb2fmlofku7bvvIjljIXlkKthcHDln7rmnKzkv6Hmga_lkoxzZXNzc2lvbl9pZO-8ieetieS_oeaBr--8jOeUqOS6jue7n-iuoeOAguWPr-W_veeVpQogIE5vdGUgb3ZlciBFbnRlckZvcmVncm91bmQ6IOWIoOmZpOaWh-S7tuWkuWFuYWx5dGljcy92Mi9ldmVudOS4i-eahOaWh-S7tgoKICBFeGNlcHRpb25DcmFzaCAtLT4gRXhjZXB0aW9uQ3Jhc2g6RXhjZXB0aW9uIENyYXNoICAKICBOb3RlIG92ZXIgRXhjZXB0aW9uQ3Jhc2g65bSp5rqD5L-h5oGv5a2Y5YKo5ZyodjMvYWN0aXZlL3Nlc3Npb25faWTmlofku7blpLnkuItleGNlcHRpb24uY2xzcmVjb3Jk5paH5Lu25LitCgogIFNpZ25hbENyYXNoIC0tPiBTaWduYWxDcmFzaDpVbml4IENyYXNoICAKICBOb3RlIG92ZXIgU2lnbmFsQ3Jhc2g65bSp5rqD5L-h5oGv5a2Y5YKo5ZyodjMvYWN0aXZlL3Nlc3Npb25faWTmlofku7blpLnkuItzaWduYWwuY2xzcmVjb3Jk5paH5Lu25Lit" target="_blank" rel="noopener">crashlytics流程图详情</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>Twitter的Crashlytics SDK接口做的非常简洁，后台也是非常友好，关于如何使用，在这里贴下别的同学的链接，不再赘述啦！<br><a href="https://www.jianshu.com/p/0a2ff9cd5c23" target="_blank" rel="noopener">iOS 崩溃统计工具-Crashlytics</a><br>了解crash收集：<a href="https://nianxi.net/ios/ios-crash-reporter.html" target="_blank" rel="noopener">漫谈iOS Crash收集框架</a></p>
<h3 id="customKey-和-customLog"><a href="#customKey-和-customLog" class="headerlink" title="customKey 和 customLog"></a>customKey 和 customLog</h3><p>customKey 和 customLog非常有用，可以跟随crash的report一起上传到服务器上，可以记录从启动到崩溃过程中的用户行为路径，方便用户定位crash根源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//customKey</span><br><span class="line">[CrashlyticsKit setUserIdentifier:@&quot;device&quot;];</span><br><span class="line">[CrashlyticsKit setUserEmail:@&quot;133@qq.com&quot;];</span><br><span class="line">[CrashlyticsKit setUserName:@&quot;xyl&quot;];</span><br><span class="line">[CrashlyticsKit setObjectValue:@&quot;testValue&quot; forKey:@&quot;testKey&quot;];</span><br><span class="line">NSDictionary *dict = @&#123;</span><br><span class="line">                       @&quot;key1&quot;:@&quot;key1&quot;,</span><br><span class="line">                       @&quot;key2&quot;:@&quot;key2&quot;</span><br><span class="line">                       &#125;;</span><br><span class="line">[CrashlyticsKit setObjectValue:dict forKey:@&quot;testKeyDict&quot;];</span><br></pre></td></tr></table></figure><br><img src="http://qiniu.xuyanlan.com/Twitter-Crashlytics-iOS/customKey.png" alt=""><br></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="技术调研" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2017-2018]]></title>
    <link href="http://yoursite.com/2018/01/30/2017-2018/"/>
    <id>http://yoursite.com/2018/01/30/2017-2018/</id>
    <published>2018-01-30T11:27:43.000Z</published>
    <updated>2018-01-30T04:18:15.000Z</updated>
    <content type="html"><![CDATA[<h4 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h4><h5 id="2017年算是比较热闹的一年吧，顺便解决了人生大事O-∩-∩-O"><a href="#2017年算是比较热闹的一年吧，顺便解决了人生大事O-∩-∩-O" class="headerlink" title="2017年算是比较热闹的一年吧，顺便解决了人生大事O(∩_∩)O~~"></a>2017年算是比较热闹的一年吧，顺便解决了人生大事O(∩_∩)O~~</h5><h5 id="换了一个工作环境"><a href="#换了一个工作环境" class="headerlink" title="换了一个工作环境"></a>换了一个工作环境</h5><p>离开了呆了3年的巨人网络，巨人网络园区应该是为数不多的工作环境舒适，设施齐全，面积广的园区啦，怀念每天中午打羽毛球or健身的场景。<br><img src="/2018/01/30/2017-2018/201701.JPG" title="&nbsp;"></p>
<a id="more"></a>
<p>新的起点(๑•̀ㅂ•́)و✧<br><img src="/2018/01/30/2017-2018/201702.JPG" title="&nbsp;"></p>
<h5 id="徒步（100公里不算多），多出去走走。"><a href="#徒步（100公里不算多），多出去走走。" class="headerlink" title="徒步（100公里不算多），多出去走走。"></a>徒步（100公里不算多），多出去走走。</h5><img src="/2018/01/30/2017-2018/2017.JPG" title="&nbsp;">
<h4 id="2018寄语"><a href="#2018寄语" class="headerlink" title="2018寄语"></a>2018寄语</h4><p>不虚度，把事情做到极致的好，多思考，多反思，多借鉴，发现好也能发现不好，敢于表达，对所承担的事情要有owner心态。可以懒，但不能懒散。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h4><h5 id="2017年算是比较热闹的一年吧，顺便解决了人生大事O-∩-∩-O"><a href="#2017年算是比较热闹的一年吧，顺便解决了人生大事O-∩-∩-O" class="headerlink" title="2017年算是比较热闹的一年吧，顺便解决了人生大事O(∩_∩)O~~"></a>2017年算是比较热闹的一年吧，顺便解决了人生大事O(∩_∩)O~~</h5><h5 id="换了一个工作环境"><a href="#换了一个工作环境" class="headerlink" title="换了一个工作环境"></a>换了一个工作环境</h5><p>离开了呆了3年的巨人网络，巨人网络园区应该是为数不多的工作环境舒适，设施齐全，面积广的园区啦，怀念每天中午打羽毛球or健身的场景。<br><img src="/2018/01/30/2017-2018/201701.JPG" title="&nbsp;"></p>]]>
    
    </summary>
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
      <category term="想法" scheme="http://yoursite.com/categories/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TextView 选中高亮动效---iOS]]></title>
    <link href="http://yoursite.com/2017/12/11/TextView-%E9%80%89%E4%B8%AD%E9%AB%98%E4%BA%AE%E5%8A%A8%E6%95%88-iOS/"/>
    <id>http://yoursite.com/2017/12/11/TextView-选中高亮动效-iOS/</id>
    <published>2017-12-10T23:05:16.000Z</published>
    <updated>2019-02-15T09:52:05.000Z</updated>
    <content type="html"><![CDATA[<p>最近有个需求，TextView显示从录音转出的文字，在播放时，播放一段文字时需要高亮选中动效（刷色+透明度变换）。<br>解决步骤：</p>
<blockquote>
<p>1：覆盖一个一模一样的textView、相同的frame、font。<br>2：设置textView的selectedRange<br>3：拿到textView的selectedTextRange<br>4：根据selectedTextRange通过selectionRectsForRange方法拿到选中的UITextSelectionRect数组，UITextSelectionRect中包含选中的rect信息，选中的首尾位置。<br>5：分析UITextSelectionRect数组给textView的layer添加CABasicAnimation的相关path和opacity等动效</p>
</blockquote>
<p>代码很简单：<br>新建一个同样的textView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//额外添加一个用来做高亮的textview</span><br><span class="line">   _maskTextview = [UITextView new];</span><br><span class="line">   _maskTextview.text = testString;</span><br><span class="line">   _maskTextview.textColor = [UIColor redColor];//你要高亮的颜色</span><br><span class="line">   _maskTextview.font = [UIFont systemFontOfSize:20];</span><br><span class="line">   _maskTextview.frame = textView.frame;</span><br><span class="line">   </span><br><span class="line">   [self.view addSubview:_maskTextview];</span><br><span class="line">   </span><br><span class="line">   _layer = [CAShapeLayer layer];</span><br><span class="line">   _layer.frame = _maskTextview.bounds;</span><br><span class="line">   _layer.fillColor = [UIColor blackColor].CGColor;//本来textview的颜色</span><br><span class="line">   [_maskTextview.layer setMask:_layer];</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>选中一段文字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> NSRange range = NSMakeRange(30, 31);</span><br><span class="line">//设置选中文字</span><br><span class="line"> _maskTextview.selectedRange = range;</span><br><span class="line"> UITextRange *textRange = _maskTextview.selectedTextRange;</span><br><span class="line">//获取选中的UITextSelectionRect数组</span><br><span class="line"> NSArray *arrays =  [_maskTextview selectionRectsForRange:textRange];</span><br></pre></td></tr></table></figure><br><img src="/2017/12/11/TextView-选中高亮动效-iOS/API.png" title="UITextSelectionRect"></p>
<p>选中的UITextSelectionRect数组分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for (UITextSelectionRect *rect in arrays) &#123;</span><br><span class="line">       //选中的rect 项可能包含多行，每一行做动效的可以通过containsStart 和 containsEnd 的height定位每行的位置</span><br><span class="line">       NSLog(@&quot;rectX is :%f&quot;,rect.rect.origin.x);</span><br><span class="line">       NSLog(@&quot;rectY is :%f&quot;,rect.rect.origin.y);</span><br><span class="line">       NSLog(@&quot;rectW is :%f&quot;,rect.rect.size.width);</span><br><span class="line">       NSLog(@&quot;rectH is :%f&quot;,rect.rect.size.height);</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;rect.containsStart is :%hhd&quot;,rect.containsStart);</span><br><span class="line">       NSLog(@&quot;rect.containsEnd is :%hhd&quot;,rect.containsEnd);</span><br><span class="line">       NSLog(@&quot;rect.isVertical is :%hhd&quot;,rect.isVertical);</span><br><span class="line">       //NSLog(@&quot;rect.writingDirection is :%d&quot;,rect.writingDirection);</span><br><span class="line">       if(rect.containsEnd || rect.containsStart) &#123;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       int line = rect.rect.size.height / lineHeight;</span><br><span class="line">       for (int i = 0; i &lt; line; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           CGFloat y = rect.rect.origin.y + (rect.rect.size.height/line) * i;</span><br><span class="line">           CGRect layerRect = CGRectMake(rect.rect.origin.x, y, rect.rect.size.width, rect.rect.size.height/line);</span><br><span class="line">           [self addSelectedLayerWithRect:layerRect];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>添加一个path效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)addSelectedLayerWithRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    //添加一个上下的高亮效果的layer</span><br><span class="line">    //如果是左右的动效的则需要把初始位置和最后的位置取出进行排序后再添加</span><br><span class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</span><br><span class="line">    layer.frame = _maskTextview.bounds;</span><br><span class="line">    layer.fillColor = [UIColor blackColor].CGColor;</span><br><span class="line">    [_layer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *fromPath = [UIBezierPath bezierPathWithRect:CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, 0)];</span><br><span class="line">    UIBezierPath *toPath = [UIBezierPath bezierPathWithRect:rect];</span><br><span class="line">    CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">    basicAnimation.duration = 5;</span><br><span class="line">    basicAnimation.repeatCount = 1;</span><br><span class="line">    basicAnimation.fromValue = (__bridge id)fromPath.CGPath;</span><br><span class="line">    basicAnimation.toValue = (__bridge id)toPath.CGPath;</span><br><span class="line">    [layer addAnimation:basicAnimation forKey:@&quot;path&quot;];</span><br><span class="line">    layer.path = toPath.CGPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>透明效果啥的自己加吧……ƪ(˘⌣˘)┐ ƪ(˘⌣˘)ʃ ┌(˘⌣˘)ʃ</p>
<p><a href="https://waterxu.github.io/2017/12/11/TextView-选中高亮动效-iOS/ViewController.m" target="_blank" rel="noopener">点击下载demo文件</a></p>
<p>后续：<br>发现直接在上面盖一个textView不满足能够滚动的case。滚动时，覆盖在上层的textView位置不动，监听scroll事件会闪烁，怎么办呢？</p>
<blockquote>
<p>1：让覆盖的textView一起滚动，直接把覆盖的textView设置成另一个textview的子view<br>2：主textView的contentSize变化时更新覆盖的textView的宽高为contentSize的宽高。</p>
</blockquote>
<p>关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)commonInit &#123;</span><br><span class="line">    self.contentSize = CGSizeZero;</span><br><span class="line">    self.userInteractionEnabled = YES;</span><br><span class="line">    self.textColor = kLayerFillColor;</span><br><span class="line">    _maskTextView = [UITextView new];</span><br><span class="line">    _maskTextView.textColor = kHighlightColor;</span><br><span class="line">    _maskTextView.userInteractionEnabled = NO;</span><br><span class="line">    _maskTextView.backgroundColor = [UIColor clearColor];</span><br><span class="line">    [self addSubview:_maskTextView];</span><br><span class="line">    _highlightLayer = [CAShapeLayer layer];</span><br><span class="line">    _highlightLayer.frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class="line">    _highlightLayer.fillColor = kLayerFillColor.CGColor;//本来textview的颜色</span><br><span class="line">    [_maskTextView.layer setMask:_highlightLayer];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setContentSize:(CGSize)contentSize &#123;</span><br><span class="line">    [super setContentSize:contentSize];</span><br><span class="line">    _maskTextView.frame = CGRectMake(0, 0, contentSize.width, contentSize.height);</span><br><span class="line">    _highlightLayer.frame = CGRectMake(0, 0, contentSize.width, contentSize.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://github.com/waterXu/textAnimationDemo" target="_blank" rel="noopener">github demo地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近有个需求，TextView显示从录音转出的文字，在播放时，播放一段文字时需要高亮选中动效（刷色+透明度变换）。<br>解决步骤：</p>
<blockquote>
<p>1：覆盖一个一模一样的textView、相同的frame、font。<br>2：设置textView的selectedRange<br>3：拿到textView的selectedTextRange<br>4：根据selectedTextRange通过selectionRectsForRange方法拿到选中的UITextSelectionRect数组，UITextSelectionRect中包含选中的rect信息，选中的首尾位置。<br>5：分析UITextSelectionRect数组给textView的layer添加CABasicAnimation的相关path和opacity等动效</p>
</blockquote>
<p>代码很简单：<br>新建一个同样的textView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//额外添加一个用来做高亮的textview</span><br><span class="line">   _maskTextview = [UITextView new];</span><br><span class="line">   _maskTextview.text = testString;</span><br><span class="line">   _maskTextview.textColor = [UIColor redColor];//你要高亮的颜色</span><br><span class="line">   _maskTextview.font = [UIFont systemFontOfSize:20];</span><br><span class="line">   _maskTextview.frame = textView.frame;</span><br><span class="line">   </span><br><span class="line">   [self.view addSubview:_maskTextview];</span><br><span class="line">   </span><br><span class="line">   _layer = [CAShapeLayer layer];</span><br><span class="line">   _layer.frame = _maskTextview.bounds;</span><br><span class="line">   _layer.fillColor = [UIColor blackColor].CGColor;//本来textview的颜色</span><br><span class="line">   [_maskTextview.layer setMask:_layer];</span><br></pre></td></tr></table></figure><br></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
