<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="纳兰若水" type="application/atom+xml">






<meta name="description" content="Medium 原文 A taste of MVVM and Reactive paradigm 原文博客 A taste of MVVM and Reactive paradigm   我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。 我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】A taste of MVVM and Reactive paradigm">
<meta property="og:url" content="http://yoursite.com/2019/06/26/mvvm【译】/index.html">
<meta property="og:site_name" content="纳兰若水">
<meta property="og:description" content="Medium 原文 A taste of MVVM and Reactive paradigm 原文博客 A taste of MVVM and Reactive paradigm   我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。 我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/06/26/mvvm【译】/1.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/26/mvvm【译】/2.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/26/mvvm【译】/3.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/26/mvvm【译】/4.jpg">
<meta property="og:image" content="http://yoursite.com/2019/06/26/mvvm【译】/5.jpg">
<meta property="og:updated_time" content="2019-06-26T09:48:06.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】A taste of MVVM and Reactive paradigm">
<meta name="twitter:description" content="Medium 原文 A taste of MVVM and Reactive paradigm 原文博客 A taste of MVVM and Reactive paradigm   我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。 我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自">
<meta name="twitter:image" content="http://yoursite.com/2019/06/26/mvvm【译】/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/26/mvvm【译】/">





  <title>【译】A taste of MVVM and Reactive paradigm | 纳兰若水</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">纳兰若水</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/mvvm【译】/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="纳兰若水">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="纳兰若水">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【译】A taste of MVVM and Reactive paradigm</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T23:48:03+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>Medium 原文 <a href="https://medium.com/flawless-app-stories/a-taste-of-mvvm-and-reactive-paradigm-5288a819cca1" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a><br> 原文博客 <a href="https://flawlessapp.io/blog/a-taste-of-mvvm-and-reactive-paradigm/" target="_blank" rel="noopener">A taste of MVVM and Reactive paradigm</a> </p>
</blockquote>
<p>我喜欢 Swift，就像许多其他面向对象的编程语言一样。 Swift 允许你表示具有某些特点和执行一些操作的真实世界对象。</p>
<p>我倾向于认为 App 是一个每个对象都是一个人的世界。他们工作和沟通。如果一个人不能独自完成工作，他需要寻求帮助。举一个项目，例如，如果经理必须自己完成所有的工作，他会发疯的。因此需要组织和委派任务，并且需要许多人在项目上进行协作：设计师，测试人员，Scrum 主管，开发人员。任务完成后，需要通知经理。</p>
<p>这可能不是一个好例子。但至少你了解 OOP 中沟通和授权的重要性。当我开始 iOS 编程时，我对“架构”一词非常感兴趣。但在做了一段时间后，这一切都归结为识别和分担责任。本文讲述了 MVC 和 MVVM 的简单 Extract 类重构，以及如何进一步研究 Rx。您可以自由地创建自己的架构，但无论您做什么，一致性都是关键，不要让您的队友感到困惑或惊讶。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>看看你最熟悉的架构 - MVC，模型视图控制器的简称。 在新建一个 iOS 项目时总是会得到一个这样的架构。 View 是您使用 <code>UIView</code>，<code>UIButton</code>，<code>UILabel</code> 呈现数据的位置。 模型只是数据的一个奇特的词。 它可以是您的实体，来自网络的数据，来自数据库的对象或来自缓存。 controller 是在 model 和 view 间进行调解的东西。<br><img src="/2019/06/26/mvvm【译】/1.jpg"></p>
<h3 id="宇宙中心-UIViewController"><a href="#宇宙中心-UIViewController" class="headerlink" title="宇宙中心 - UIViewController"></a>宇宙中心 - UIViewController</h3><p> <code>ViewController</code> 的问题在于它往往是巨大的。 Apple 把它作为宇宙的中心，它拥有许多属性和责任。你可以用 <code>UIViewController</code> 做很多事情。诸如与故事板交互，管理视图，配置视图轮换，状态恢复等事情。 <code>UIViewController</code> 设计有很多钩子，可以覆盖和自定义。<br><a id="more"></a></p>
<p>看看 <code>UIViewController</code> <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller" target="_blank" rel="noopener">文档</a>中的许多部分，如果没有 <code>UIViewController</code>，则无法执行以下操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func viewDidLoad()</span><br><span class="line">var preferredStatusBarStyle: UIStatusBarStyle &#123; get &#125;</span><br><span class="line">UITableViewDataSource</span><br><span class="line">var presentationController: UIPresentationController? &#123; get &#125;</span><br><span class="line">func childViewControllerForScreenEdgesDeferringSystemGestures() -&gt; UIViewController?</span><br><span class="line">func didMove(toParentViewController parent: UIViewController?)</span><br><span class="line">var systemMinimumLayoutMargins: NSDirectionalEdgeInsets</span><br><span class="line">var edgesForExtendedLayout: UIRectEdge</span><br><span class="line">var previewActionItems: [UIPreviewActionItem]</span><br><span class="line">var navigationItem: UINavigationItem</span><br><span class="line">var shouldAutorotate: Bool</span><br></pre></td></tr></table></figure>
<p>随着应用程序的增长，我们需要为其他逻辑添加更多代码。例如网络，数据源，处理多个代表，呈现子视图控制器。当然，我们可以将所有内容放在视图控制器上，但这会产生大视图控制器并提高滚动技能。这是你失去责任的全局，因为所有的东西都停留在巨型视图控制器中。您倾向于引入代码重复，并且很难修复错误，因为它们遍布各处。</p>
<p>Windows Phone 中的 <code>Page</code> 或 Android 中的 <code>Activity</code> 也是如此。它们用于屏幕或部分功能屏幕。某些操作只能通过它们完成，如 <a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.page.onnavigatedto%28v=vs.105%29.aspx" target="_blank" rel="noopener">Page.OnNavigatedTo</a> ，<a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.page.onnavigatedto%28v=vs.105%29.aspx" target="_blank" rel="noopener">Activity.onCreate</a> 。</p>
<h3 id="架构术语"><a href="#架构术语" class="headerlink" title="架构术语"></a>架构术语</h3><p>当 ViewController 做很多事情时你会怎么做？您将工作偏移到其他组件。顺便说一句，如果您希望其他对象执行用户输入处理，则可以使用 Presenter。如果 Presenter 做得太多，那么它可以将业务逻辑偏移到 Interactor。此外，还有更多流行语可供使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let buzzWords = [</span><br><span class="line">  &quot;Model&quot;, &quot;View&quot;, &quot;Controller&quot;, &quot;Entity&quot;, &quot;Router&quot;, &quot;Clean&quot;, &quot;Reactive&quot;, </span><br><span class="line">  &quot;Presenter&quot;, &quot;Interactor&quot;, &quot;Megatron&quot;, &quot;Coordinator&quot;, &quot;Flow&quot;, &quot;Manager&quot;</span><br><span class="line">]</span><br><span class="line">let architecture = buzzWords.shuffled().takeRandom()</span><br><span class="line">let acronym = architecture.makeAcronym()</span><br></pre></td></tr></table></figure>
<img src="/2019/06/26/mvvm【译】/2.jpg">
<p>在所有流行语汇编完成后，我们得到了一个架构。<a href="https://github.com/onmyway133/fantastic-ios-architecture" target="_blank" rel="noopener">这里有更多</a>，包括简单的提取类重构，拥抱 MVC 或从 Clean Code，Rx，EventBus 或 Redux 中获取灵感。选择取决于项目，有些团队更喜欢一种架构而不是另一种架构。</p>
<h3 id="务实的程序员"><a href="#务实的程序员" class="headerlink" title="务实的程序员"></a>务实的程序员</h3><p>人们对什么是好的架构有不同的看法。对我来说，这是关于明确的关注分离，良好的沟通模式和使用舒适度。架构中的每个组件都应该是可识别的并且具有特定的角色。沟通必须清楚，以便我们知道哪个对象正在相互通信。这与良好的依赖注入一起将使测试更容易。</p>
<p>理论上听起来不错的事情在实践中可能效果不佳。分离的域对象很酷，协议扩展很酷，多层抽象很酷。但是它们中有太多可能是个问题。</p>
<p>如果你对设计模式有足够的了解，你就知道它们都归结为这些简单的原则：</p>
<ul>
<li>封装变化的内容：确定应用程序的各个方面的变化，并将它们与保持不变的方面分开。</li>
<li>编程到接口，而不是实现</li>
<li>更喜欢继承的组合</li>
</ul>
<p>如果我们应该掌握一件事，那就是构图。关键是要确定责任并以合理和一致的方式撰写。咨询你的队友最适合的事情。总是编 写代码，并认为您也将成为未来的维护者。然后你会用不同的方式写它。</p>
<h3 id="不要和系统做斗争"><a href="#不要和系统做斗争" class="headerlink" title="不要和系统做斗争"></a>不要和系统做斗争</h3><p>一些架构引入了全新的范例。其中有些很麻烦，人们编写脚本来生成模板代码。有很多解决问题的方法是好的。但对我来说，有时候我觉得他们在与这个体系作斗争。有些任务很容易，而有些琐碎的任务则变得非常困难。我们不应该仅仅因为一个架构是时髦的，就把自己限制在一个架构中。要务实，不要武断。</p>
<p>在 iOS 中，我们应该接受 MVC。<code>UIViewController</code> 不适用于内容的全屏显示。它们可以包含并组成以拆分功能。我们可以使用 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">Coordinator</a> 和 <a href="https://github.com/onmyway133/blog/issues/106" target="_blank" rel="noopener">FlowController</a> 来管理依赖关系和处理流。<a href="https://www.swiftbysundell.com/posts/custom-container-view-controllers-in-swift" target="_blank" rel="noopener">状态转换容器</a>，嵌入式逻辑<a href="https://www.swiftbysundell.com/posts/logic-controllers-in-swift" target="_blank" rel="noopener">控制器</a>，全屏内容的一<a href="https://davedelong.com/blog/2017/11/06/a-better-mvc-part-3-fixing-massive-view-controller/" target="_blank" rel="noopener">部分</a>。这种令人欣慰的 <code>ViewController</code> 方法在 iOS 中可以很好地与 MVC 配合使用，是我的首选方法。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><img src="/2019/06/26/mvvm【译】/3.jpg">
<p>另一个足够好的方法是将一些任务重定向到另一个对象，我们称之为 ViewModel 。这个名字不重要，你可以把它命名为反应堆，大师，恐龙。重要的是你的团队要有一个约定的名字。viewModel 从 ViewController 中获取一些任务，并在完成后进行报告。CocoaTouch 中有一些<a href="https://www.objc.io/issues/7-foundation/communication-patterns/" target="_blank" rel="noopener">通信模式</a>，例如要使用的委托、闭包。</p>
<p>ViewModel 是独立的，没有对 UIKit 的引用，只有输入和输出。我们可以把<a href="https://ashfurrow.com/blog/mvvm-is-exceptionally-ok/" target="_blank" rel="noopener">很多东西</a>放到 ViewModel 中，比如计算、格式化、联网、业务逻辑。此外，如果您不喜欢 ViewModel 变得庞大，那么您肯定需要创建一些专用的对象。ViewModel 是获得超薄 ViewController 的第一步。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>下面是一个非常简单的视图模型，它基于<code>用户</code>模型格式化数据，是同步进行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ProfileController: UIViewController &#123;</span><br><span class="line">  override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let viewModel = ViewModel(user: user)</span><br><span class="line">    nameLabel.text = viewModel.name</span><br><span class="line">    birthdayLabel.text = viewModel.birthdayString</span><br><span class="line">    salaryLabel.text = viewModel.salary</span><br><span class="line">    piLabel.text = viewModel.millionthDigitOfPi</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>我们一直在使用异步 API。如果我们想显示用户的 Facebook 好友数量呢？为了实现这一点，我们需要调用 Facebook  API，而这个操作需要时间。视图模型可以通过闭包进行报告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewModel.getFacebookFriends &#123; friends in</span><br><span class="line">  self.friendCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内部，ViewModel 可以将任务重定向到专用的 Facebook API 客户端对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  func getFacebookFriends(completion: [User] -&gt; Void) &#123;</span><br><span class="line">    let client = APIClient()</span><br><span class="line">    client.getFacebookFriends(for: user) &#123; friends in</span><br><span class="line">      DispatchQueue.main.async &#123;</span><br><span class="line">        completion(friends)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Android版Jetpack"><a href="#Android版Jetpack" class="headerlink" title="Android版Jetpack"></a>Android版Jetpack</h3><img src="/2019/06/26/mvvm【译】/4.jpg">
<p>谷歌在 2017 年的谷歌 IO 上推出了 Android 架构组件，现在是 Jetpack 的一部分。它有 ViewModel 和 LiveData ，这也是一种应用于 Android 的 MVVM 。ViewModel 通过配置更改存活下来，并根据要使用的活动的 LiveData 通知结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?, persistentState: PersistableBundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState, persistentState)</span><br><span class="line"></span><br><span class="line">        val model = ViewModelProviders.of(this).get(MyViewModel::class.java)</span><br><span class="line">        model.getUsers().observe(this, &#123; users -&gt;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是我喜欢 ViewModel 的原因之一。如果我们遵循这样的 ViewModel ，那么 iOS 和 Android 之间的代码结构就会变得相似。不需要一些随机的 JavaScript 跨平台解决方案。您只需学习一次这个概念，就可以将其应用到 iOS 和 Android 上。我在 iOS 上学习 ViewModel、RxSwift ，当我在 Android 上使用 RxJava 和 RxBinding 时，感觉就像在家一样。Kickstarter 项目也证明了这在 iOS 和 Android 应用程序中很好地工作。</p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>为了封装闭包，我们可以创建一个名为 Binding 的类，它可以通知一个或多个监听器。它利用了 <code>Didset</code> 的优点，使其可观测性变得清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Binding&lt;T&gt; &#123;</span><br><span class="line">  var value: T &#123;</span><br><span class="line">    didSet &#123;</span><br><span class="line">      listener?(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private var listener: ((T) -&gt; Void)?</span><br><span class="line">  init(value: T) &#123;</span><br><span class="line">    self.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  func bind(_ closure: @escaping (T) -&gt; Void) &#123;</span><br><span class="line">    closure(value)</span><br><span class="line">    listener = closure</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是如何在 ViewModel 中使用的 Binding 示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  let friends = Binding&lt;[User]&gt;(value: [])</span><br><span class="line">  init() &#123;</span><br><span class="line">    getFacebookFriends &#123;</span><br><span class="line">      friends.value = $0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  func getFacebookFriends(completion: ([User]) -&gt; Void) &#123;</span><br><span class="line">  	// Do the work</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论何时，当获取或更改 friends 时，ViewController 会相应地更新。这叫做对变化的反应。<br>你经常看到 MVVM 引入了反应式框架，这是有原因的。它们提供了许多链接操作符，并使反应式编程更容易和更具声明性。</p>
<h3 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h3><p>也许 Swift 中最常见的反应式框架是 RXSwift。我喜欢它的一点是它遵循了反动模式。因此，如果您已经使用了 RxJava 、RxJS 或 RxKotlin ，您会感到更加熟悉。</p>
<h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><img src="/2019/06/26/mvvm【译】/5.jpg">
<p>RXSwift 通过 Observable 统一了同步和异步操作。你应该像下面这么做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  let friends: Observable&lt;[User]&gt;</span><br><span class="line">  init() &#123;</span><br><span class="line">    let client = APIClient()</span><br><span class="line">    friends = Observable&lt;[User]&gt;.create(&#123; subscriber in</span><br><span class="line">      client.getFacebookFriends(completion: &#123; friends in</span><br><span class="line">        subscriber.onNext(friends)</span><br><span class="line">        subscriber.onCompleted()</span><br><span class="line">      &#125;)</span><br><span class="line">      return Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RXSwift 的强大功能在于它的众多操作符，这些操作符可以帮助您链接可观察的对象。在这里，您可以调用 2 个网络请求，等待两个请求都完成，然后汇总 friends。这是非常流线型的，可以节省你很多时间。您可以在这里注册 Observable 监听，当请求完成时会触发它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  viewModel.friends.subscribe(onNext: &#123; friends in</span><br><span class="line">    self.friendsCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>ViewModel 和 RX 的一个优点是，我们可以使用 Observable 分离输入和输出，它提供了一个清晰的界面。点击阅读更多源码内容：<a href="https://github.com/onmyway133/blog/issues/87" target="_blank" rel="noopener"> Input and output container </a>。</p>
<p>下面很明显， fetch 是一个输入，而 friends 是可行的输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ViewModel &#123;</span><br><span class="line">  class Input &#123;</span><br><span class="line">    let fetch = PublishSubject&lt;()&gt;()</span><br><span class="line">  &#125;</span><br><span class="line">  class Output &#123;</span><br><span class="line">    let friends: Driver&lt;[User]&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  let apiClient: APIClient</span><br><span class="line">  let input: Input</span><br><span class="line">  let output: Output</span><br><span class="line">  init(apiClient: APIClient) &#123;</span><br><span class="line">    self.apiClient = apiClient</span><br><span class="line">    // Connect input and output</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ProfileViewController: BaseViewController&lt;ProfileView&gt; &#123;</span><br><span class="line">  let viewModel: ProfileViewModelType</span><br><span class="line">  init(viewModel: ProfileViewModelType) &#123;</span><br><span class="line">    self.viewModel = viewModel</span><br><span class="line">  &#125;</span><br><span class="line">  override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    // Input</span><br><span class="line">    viewModel.input.fetch.onNext(())</span><br><span class="line">    // Output</span><br><span class="line">    viewModel.output.friends.subscribe(onNext: &#123; friends in</span><br><span class="line">      self.friendsCountLabel.text = &quot;\(friends.count)&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reactive-如何工作"><a href="#reactive-如何工作" class="headerlink" title="reactive 如何工作"></a>reactive 如何工作</h3><p>如果你喜欢 Rx ，在使用一些框架一段时间后，了解它们是很好的。有一些概念，如 <code>Signal</code>, <code>SignalProduce</code>r<code>,</code>Observable<code>,</code>Promise<code>,</code>Future<code>,</code>Task<code>,</code>Job<code>,</code>Launcher<code>,</code>Async<code>，有些人对它们可以有很好的区分。在这里，我简单地称之为</code>Signal`，它是一种可以发出信号值的东西。</p>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p><code>Signal</code> 及其 <code>Result</code> 只是 <a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="noopener">Monads</a> ，它是可以被映射和链接的东西。</p>
<p><code>Signal</code> 使用于延迟执行回调方法。它可以获取或推送。这就是 <code>Signal</code> 更新其值和调用回调的顺序的方式。</p>
<p>执行回调方法意味着我们将一个函数传递给另一个函数。传入函数在适当的时候被调用。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>Monad 可以是同步模式或异步模式。同步更容易理解，但异步在实践中已经很熟悉和使用了。</p>
<ul>
<li>同步：通过返回立即得到返回值</li>
<li>异步：通过回调块得到返回值</li>
</ul>
<p>下面是一个简单的同步和异步自由函数示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Sync</span><br><span class="line">func sum(a: Int, b: Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Async</span><br><span class="line">func sum(a: Int, b: Int, completion: Int -&gt; Void) &#123;</span><br><span class="line">    // Assumed it is a very long task to get the result</span><br><span class="line">    let result = a + b</span><br><span class="line"></span><br><span class="line">    completion(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及同步和异步如何应用于返回值类型。注意异步版本，我们在一个完成闭包中得到转换值，而不是从函数立即返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T&gt; &#123;</span><br><span class="line">  case value(value: T)</span><br><span class="line">  case failure(error: Error)</span><br><span class="line"></span><br><span class="line">  // Sync</span><br><span class="line">  public func map&lt;U&gt;(f: (T) -&gt; U) -&gt; Result&lt;U&gt; &#123;</span><br><span class="line">    switch self &#123;</span><br><span class="line">    case let .value(value):</span><br><span class="line">      return .value(value: f(value))</span><br><span class="line">    case let .failure(error):</span><br><span class="line">      return .failure(error: error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Async</span><br><span class="line">  public func map&lt;U&gt;(f: @escaping ((T), (U) -&gt; Void) -&gt; Void) -&gt; (((Result&lt;U&gt;) -&gt; Void) -&gt; Void) &#123;</span><br><span class="line">    return &#123; g in   // g: Result&lt;U&gt; -&gt; Void</span><br><span class="line">      switch self &#123;</span><br><span class="line">      case let .value(value):</span><br><span class="line">        f(value) &#123; transformedValue in  // transformedValue: U</span><br><span class="line">          g(.value(value: transformedValue))</span><br><span class="line">        &#125;</span><br><span class="line">      case let .failure(error):</span><br><span class="line">        g(.failure(error: error))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推送信号"><a href="#推送信号" class="headerlink" title="推送信号"></a>推送信号</h3><p>给出这样一个信号链：<br><code>A -(map)-&gt; B -(flatMap)-&gt; C -(flatMap)-&gt; D -(subscribe)</code><br>推送信号，当 信号A 在一个事件发生时，它通过 CallBacks 事件传播。<code>PushSignal</code> 在 RxSwift 中类似于 <code>PublishSubject</code>。</p>
<ul>
<li>通过向源信号发送事件触发。</li>
<li>我们必须保持 A，因为它使其信号保持</li>
<li>我们订阅最后一个 D</li>
<li>我们将事件发送到第一个 A</li>
<li>A 的回调被调用，它依次使用 A 的映射结果调用 B 的回调，然后 B 的回调使用 B 的平面映射结果调用 C 的回调，依此类推。</li>
</ul>
<p>它类似于 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a> ，您可以在我的 <a href="https://github.com/onmyway133/Then/blob/master/Pod/Classes/Promise.swift" target="_blank" rel="noopener">Then framework</a> 中看到 Promise A+ 的 Swift 实现。现在，这里是一个简单的 <code>PushSignal</code> 的 Swift 4 实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public final class PushSignal&lt;T&gt; &#123;</span><br><span class="line">  var event: Result&lt;T&gt;?</span><br><span class="line">  var callbacks: [(Result&lt;T&gt;) -&gt; Void] = []</span><br><span class="line">  let lockQueue = DispatchQueue(label: &quot;Serial Queue&quot;)</span><br><span class="line"></span><br><span class="line">  func notify() &#123;</span><br><span class="line">    guard let event = event else &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callbacks.forEach &#123; callback in</span><br><span class="line">      callback(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func update(event: Result&lt;T&gt;) &#123;</span><br><span class="line">    lockQueue.sync &#123;</span><br><span class="line">      self.event = event</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func subscribe(f: @escaping (Result&lt;T&gt;) -&gt; Void) -&gt; Signal&lt;T&gt; &#123;</span><br><span class="line">    // Callback</span><br><span class="line">    if let event = event &#123;</span><br><span class="line">      f(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callbacks.append(f)</span><br><span class="line"></span><br><span class="line">    return self</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func map&lt;U&gt;(f: @escaping (T) -&gt; U) -&gt; Signal&lt;U&gt; &#123;</span><br><span class="line">    let signal = Signal&lt;U&gt;()</span><br><span class="line"></span><br><span class="line">    _ = subscribe &#123; event in</span><br><span class="line">      signal.update(event: event.map(f: f))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return signal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是如何使用 PushSignal 将链从字符串转换为其长度，您应该看到 4，即打印的字符串 “test” 的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let signal = PushSignal&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">_ = signal.map &#123; value in</span><br><span class="line">  return value.count</span><br><span class="line">&#125;.subscribe &#123; event in</span><br><span class="line">  if case let .value(value) = event &#123;</span><br><span class="line">    print(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print(&quot;error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal.update(event: .value(value: &quot;test&quot;))</span><br></pre></td></tr></table></figure>
<h3 id="获取信号"><a href="#获取信号" class="headerlink" title="获取信号"></a>获取信号</h3><p>给出这样一个信号链：<br><code>A -(map)-&gt; B -(flatMap)-&gt; C -(flatMap)-&gt; D -(subscribe)</code></p>
<p>获取信号，有时称为 Future，意味着当我们订阅最终的信号 D 时，它会导致先前的信号被激活：</p>
<ul>
<li>通过订阅最终信号 D 触发；</li>
<li>我们必须保持 D，因为它使其信号保持</li>
<li>我们订阅最后一个 D</li>
<li>D 的操作运行，它导致 C 的操作运行，… 然后 A 的操作运行。执行任务（如获取网络、检索数据库、文件访问、大量计算等）以获取结果，并调用A的完成。然后，A 的完成调用 B 的完成，结果由 B 的映射映射，…一直映射到订阅方的完成 block。</li>
</ul>
<p>这里是 PullSignal 的一个 Swift 4 实现。PullSignal 类似于 Rxswift 中的 Observable 和 ReactiveSwift 中的SignalProducer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public struct PullSignal&lt;T&gt; &#123;</span><br><span class="line">  let operation: ((Result&lt;T&gt;) -&gt; Void) -&gt; Void</span><br><span class="line"></span><br><span class="line">  public init(operation: @escaping ((Result&lt;T&gt;) -&gt; Void) -&gt; Void) &#123;</span><br><span class="line">    self.operation = operation</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func start(completion: (Result&lt;T&gt;) -&gt; Void) &#123;</span><br><span class="line">    operation() &#123; event in</span><br><span class="line">      completion(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public func map&lt;U&gt;(f: @escaping (T) -&gt; U) -&gt; PullSignal&lt;U&gt; &#123;</span><br><span class="line">    return PullSignal&lt;U&gt; &#123; completion in</span><br><span class="line">      self.start &#123; event in</span><br><span class="line">        completion(event.map(f: f))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链是不活动的，直到您调用链中的最后一个信号开始，这将触发操作流到第一个信号。运行这个代码，您应该看到 4 ，控制台上打印的字符串 “test” 的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let signal = PullSignal&lt;String&gt; &#123; completion in</span><br><span class="line">  // There should be some long running operation here</span><br><span class="line">  completion(Result.value(value: &quot;test&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal.map &#123; value in</span><br><span class="line">  value.count</span><br><span class="line">&#125;.start &#123; event in</span><br><span class="line">  if case let .value(value) = event &#123;</span><br><span class="line">    print(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print(&quot;error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我希望这些代码段足够简单，能够帮助您理解信号在后台是如何工作的，以及如何区分冷热信号。为了得到一个完全工作的信号框架，您需要实现更多的操作。如 <code>retry</code> , <code>rebounce</code> , <code>throttle</code> , <code>queue</code> , <code>flatten</code>, <code>filter</code>, <code>delay</code>, <code>combine</code> 和添加 UIKit 支持就像 RxCocoa 所做的。了解如何在我的 <a href="https://github.com/onmyway133/archives/tree/master/Signal/Pod/Classes" target="_blank" rel="noopener">Signal repo</a> 中实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>架构是一个非常常见的话题。希望这篇文章能给您的决策带来一些想法。MVC 在 iOS 中占主导地位，MVVM 是一个好朋友，RX 是一个强大的工具。以下是一些更有趣的读物：</p>
<ul>
<li><a href="https://ashfurrow.com/blog/mvvm-is-exceptionally-ok/" target="_blank" rel="noopener">MVVM is Exceptionally OK</a></li>
<li><a href="https://academy.realm.io/posts/krzysztof-zablocki-mDevCamp-ios-architecture-mvvm-mvc-viper/" target="_blank" rel="noopener">Good iOS Application Architecture: MVVM vs. MVC vs. VIPER</a></li>
<li><a href="https://www.youtube.com/watch?v=YWVzCd5FYbs" target="_blank" rel="noopener">A Better MVC</a></li>
<li><a href="https://blog.uptech.team/taming-great-complexity-mvvm-coordinators-and-rxswift-8daf8a76e7fd" target="_blank" rel="noopener">Taming Great Complexity: MVVM, Coordinators and RxSwift</a></li>
<li><a href="http://blogs.microsoft.co.il/bnaya/2010/03/13/rx-for-beginners-part-9-hot-vs-cold-observable/" target="_blank" rel="noopener">Rx — for beginners (part 9): Hot Vs. Cold observable</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md" target="_blank" rel="noopener">Hot and Cold Observables</a></li>
<li><a href="https://stackoverflow.com/questions/17082255/when-to-use-ienumerable-vs-iobservable" target="_blank" rel="noopener">When to use IEnumerable vs IObservable?</a></li>
<li><a href="https://www.youtube.com/watch?v=AcDaWe3S75c" target="_blank" rel="noopener">Functional Reactive Programming without Black Magic</a></li>
<li><a href="https://www.youtube.com/watch?v=mbd6g7NfR-8" target="_blank" rel="noopener">Swift Sync and Async Error Handling</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/20/iOS-crash-report/" rel="next" title="如何自建 Crash 平台">
                <i class="fa fa-chevron-left"></i> 如何自建 Crash 平台
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDI4NC82ODM5"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="纳兰若水">
            
              <p class="site-author-name" itemprop="name">纳兰若水</p>
              <p class="site-description motion-element" itemprop="description">随便写写读书笔记、技术学习、随想、生活、游记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/waterXu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/xuyanlan" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC"><span class="nav-number">1.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宇宙中心-UIViewController"><span class="nav-number">2.</span> <span class="nav-text">宇宙中心 - UIViewController</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#架构术语"><span class="nav-number">3.</span> <span class="nav-text">架构术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#务实的程序员"><span class="nav-number">4.</span> <span class="nav-text">务实的程序员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不要和系统做斗争"><span class="nav-number">5.</span> <span class="nav-text">不要和系统做斗争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM"><span class="nav-number">6.</span> <span class="nav-text">MVVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步"><span class="nav-number">7.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步"><span class="nav-number">8.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android版Jetpack"><span class="nav-number">9.</span> <span class="nav-text">Android版Jetpack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定"><span class="nav-number">10.</span> <span class="nav-text">绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxSwift"><span class="nav-number">11.</span> <span class="nav-text">RxSwift</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observable"><span class="nav-number">12.</span> <span class="nav-text">Observable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入和输出"><span class="nav-number">13.</span> <span class="nav-text">输入和输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reactive-如何工作"><span class="nav-number">14.</span> <span class="nav-text">reactive 如何工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monad"><span class="nav-number">15.</span> <span class="nav-text">Monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步和异步"><span class="nav-number">16.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送信号"><span class="nav-number">17.</span> <span class="nav-text">推送信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取信号"><span class="nav-number">18.</span> <span class="nav-text">获取信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">19.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">纳兰若水</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  
  

  

  

  

</body>
</html>
